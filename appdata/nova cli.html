<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://glitch.com/favicon.ico" />
    <!-- Nova Icon SVG remains the same -->
    <meta name="nova-icon" content="...">

    <title>Nova CLI Enhanced</title>

    <style>
        /* Base CSS - largely unchanged, it's pretty good */
        html {
            box-sizing: border-box;
            font-size: 16px;
        }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            margin: 1rem;
            font-family: 'Space Mono', monospace;
            line-height: 1.5;
            letter-spacing: 0.7px;
            background: #1e1e1e;
            color: #e0e0e0; /* Default text color */
            overflow: hidden; /* Prevent body scroll */
        }
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #2a2a2a; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
        img, video { height: auto; max-width: 100%; }
        small { opacity: 0.7; }

        /* Terminal styles */
        #terminal-output {
            background-color: #101010;
            color: white;
            border-radius: 10px 10px 0 0;
            padding: 15px;
            height: calc(100vh - 75px); /* Adjusted height */
            overflow-y: auto; /* Changed to auto */
            scroll-behavior: smooth;
            word-wrap: break-word; /* Ensure long lines wrap */
        }

        #terminal-input {
            background-color: #0c0c0c;
            color: white;
            width: 100%;
            font-family: 'Space Mono', monospace;
            border: none;
            padding: 12px 15px;
            font-size: 16px;
            border-radius: 0 0 10px 10px;
            outline: none;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3); /* Subtle shadow */
        }

        /* Output entry styling */
        .output-entry {
            margin-bottom: 0.8em;
            animation: fadeIn 0.3s ease-out;
        }
        .prompt-line {
            color: #88c0d0; /* Nord color for prompt */
            margin-right: 5px;
            user-select: none;
        }
        .command-line {
            color: #e5e9f0; /* Lighter text for command */
        }
        .output-content {
            padding-left: 5px; /* Indent output slightly */
            color: #a3be8c; /* Greenish for success output */
        }
        .output-content.error {
            color: #bf616a; /* Reddish for error output */
        }
        .output-content pre { /* Style for JSON output */
            background-color: #2e3440;
            padding: 8px;
            border-radius: 4px;
            font-size: 0.9em;
            overflow-x: auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
</head>

<body>
    <!-- Use more semantic names -->
    <div id="terminal-output">
        <div>Welcome to Nova CLI Enhanced! Type 'help' for commands.</div>
    </div>
    <input id="terminal-input" autocomplete="off" placeholder=">>>" autofocus>

    <script>
        // --- Self-Executing Anonymous Function (IIFE) to encapsulate scope ---
        (() => {
            // --- DOM Element Caching ---
            const outputElement = document.getElementById("terminal-output");
            const inputElement = document.getElementById("terminal-input");

            // --- State ---
            let currentDirectory = "/";
            let isProcessing = false;
            const commandHistory = [];
            let historyIndex = -1; // -1 means pointing before the first history item

            // --- Utility Functions ---

            /**
             * Displays output in the terminal.
             * @param {string} commandText - The command that was entered.
             * @param {string} outputText - The result/output of the command.
             * @param {boolean} [isError=false] - Whether the output is an error message.
             */
            const displayOutput = (commandText, outputText, isError = false) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'output-entry';

                // Sanitize commandText before inserting as HTML
                const sanitizedCommand = commandText.replace(/</g, "<").replace(/>/g, ">");

                entryDiv.innerHTML = `
                    <div>
                        <span class="prompt-line">nova@cli:${currentDirectory}$</span>
                        <span class="command-line">${sanitizedCommand}</span>
                    </div>
                    <div class="output-content ${isError ? 'error' : ''}">${outputText}</div>
                `;

                outputElement.appendChild(entryDiv);
                // Scroll to the bottom smoothly
                outputElement.scrollTop = outputElement.scrollHeight;
            };

            /**
             * Displays an error message in the terminal.
             * @param {string} commandText - The command that caused the error.
             * @param {string | Error} error - The error message or Error object.
             */
            const displayError = (commandText, error) => {
                const message = (error instanceof Error) ? `${error.name}: ${error.message}` : String(error);
                console.error(`Command "${commandText}" failed:`, error); // Log detailed error to console
                displayOutput(commandText, `Error: ${message.replace(/</g, "<").replace(/>/g, ">")}`, true);
            };

            /**
             * Safely formats various data types for display.
             * @param {*} data - The data to format.
             * @returns {string} HTML-safe string representation.
             */
            const formatOutput = (data) => {
                if (data === null || data === undefined) {
                    return String(data);
                }
                if (data instanceof Error) {
                    return `<pre>Error: ${data.message}\nStack: ${data.stack}</pre>`;
                }
                if (typeof data === 'function') {
                    return `Function: ${data.name || 'anonymous'}\n<pre>${data.toString().replace(/</g, "<")}</pre>`;
                }
                if (data instanceof Element) {
                    return `DOM Element: <pre>${data.outerHTML.replace(/</g, "<")}</pre>`;
                }
                if (typeof data === 'object') {
                    try {
                        // Use JSON.stringify for objects/arrays, null replacer, 2-space indent
                        // Escape HTML chars in the resulting string
                        const jsonString = JSON.stringify(data, null, 2);
                        return `<pre>${jsonString.replace(/</g, "<")}</pre>`;
                    } catch (e) {
                        return '[Circular Object or JSON Error]';
                    }
                }
                // For primitives (string, number, boolean), convert to string and escape
                return String(data).replace(/</g, "<").replace(/>/g, ">");
            };


            // --- Command Definitions ---
            // Using an object map for commands. Keys are command names (lowercase).
            // Values are objects with an `execute` async function and a `description`.
            const commands = {
                help: {
                    description: "Displays this help message.",
                    execute: async () => {
                        let helpText = "Available Commands:<br>";
                        Object.entries(commands).sort().forEach(([name, { description }]) => {
                             // Basic formatting, adjust as needed
                             helpText += `- <strong style="color: #81A1C1;">${name}</strong>: ${description}<br>`;
                        });
                        return helpText;
                    }
                },
                date: {
                    description: "Shows the current date.",
                    execute: async () => new Date().toDateString()
                },
                time: {
                    description: "Shows the current time.",
                    execute: async () => new Date().toLocaleTimeString()
                },
                clear: {
                    description: "Clears the terminal screen.",
                    execute: async () => {
                        outputElement.innerHTML = '<div>Terminal cleared.</div>';
                        return ""; // Return empty string to avoid extra output line
                    }
                },
                pwd: {
                    description: "Prints the current working directory.",
                    execute: async () => `Current directory: ${currentDirectory}`
                },
                cd: {
                    description: "Changes the current directory. Use 'cd ..' to go up.",
                    execute: async (args) => {
                        const targetDir = args[0];
                        if (!targetDir || targetDir === '.' || targetDir === currentDirectory) {
                            return `Staying in ${currentDirectory}`;
                        }
                        if (targetDir === '..') {
                            if (currentDirectory === '/') {
                                return "Already at root directory.";
                            }
                            // Simple parent directory logic
                            const parts = currentDirectory.split('/').filter(p => p); // Filter empty strings
                            parts.pop();
                            currentDirectory = '/' + parts.join('/');
                            if (currentDirectory === "//") currentDirectory = "/"; // Handle root case
                        } else {
                            // Basic path joining, assumes target is relative for simplicity
                            // No actual filesystem means we just simulate path changes
                            const newPath = targetDir.startsWith('/')
                                ? targetDir // Absolute path
                                : (currentDirectory === '/' ? '' : currentDirectory) + '/' + targetDir; // Relative path

                            // Simple normalization (remove trailing slash if not root)
                            currentDirectory = newPath.replace(/\/$/, '');
                            if (!currentDirectory) currentDirectory = "/"; // Handle becoming root
                        }
                        // In a real scenario, you'd validate if the directory exists here
                        return `Changed directory to ${currentDirectory}`;
                    }
                },
                ls: {
                    description: "Lists 'files' in the current directory (simulated).",
                    execute: async () => {
                        // Simulate listing files based on directory
                        // Replace with actual call if available (like window.parent.getFileNamesByFolder)
                        try {
                            // Example: Try calling parent function if it exists
                            if (typeof window.parent?.getFileNamesByFolder === 'function') {
                                const files = await window.parent.getFileNamesByFolder(currentDirectory);
                                if (!Array.isArray(files)) {
                                    return "Received non-array data from getFileNamesByFolder.";
                                }
                                if (files.length === 0) {
                                    return "Directory is empty.";
                                }
                                return files.map(item => `Name: '${item.name}' ${item.id ? `ID: '${item.id}'` : ''}`).join('<br>');
                            } else {
                                // Simulate some files based on path
                                if (currentDirectory === '/') {
                                    return "home/<br>documents/<br>README.txt";
                                } else if (currentDirectory.startsWith('/home')) {
                                    return "projects/<br>notes.txt";
                                } else {
                                    return "file1.dat<br>another_folder/";
                                }
                            }
                        } catch (error) {
                           throw new Error(`Failed to list files: ${error.message}`);
                        }
                    }
                },
                battery: {
                    description: "Gets battery status information.",
                    execute: async () => {
                        if (!navigator.getBattery) {
                            throw new Error("Battery Status API not supported.");
                        }
                        const battery = await navigator.getBattery();
                        const level = (battery.level * 100).toFixed(1);
                        const charging = battery.charging ? "Charging" : "Discharging";
                        const chargingTime = battery.chargingTime === Infinity ? 'N/A' : `${(battery.chargingTime / 60).toFixed(0)} min`;
                        const dischargingTime = battery.dischargingTime === Infinity ? 'N/A' : `${(battery.dischargingTime / 60).toFixed(0)} min`;

                        return `Level: ${level}% (${charging})<br>Time to full: ${chargingTime}<br>Time to empty: ${dischargingTime}`;
                    }
                },
                device: {
                    description: "Shows device and browser information.",
                    execute: async () => {
                        const { userAgent, platform, language, languages, hardwareConcurrency, deviceMemory } = navigator;
                        const { width, height, colorDepth, pixelDepth } = window.screen;

                        let deviceInfo = `Platform: ${platform}<br>Language: ${language} (${languages.join(', ')})<br>`;
                        if (hardwareConcurrency) deviceInfo += `CPU Cores: ${hardwareConcurrency}<br>`;
                        if (deviceMemory) deviceInfo += `Approx. RAM: ${deviceMemory} GB<br>`;
                        deviceInfo += `Screen: ${width}x${height} (${colorDepth}-bit color, ${pixelDepth}-bit pixel)<br>`;
                        deviceInfo += `User Agent: ${userAgent}`;
                        return deviceInfo;
                    }
                },
                memory: {
                    description: "Shows JS heap memory usage (if available).",
                    execute: async () => {
                        if (!performance.memory) {
                           throw new Error("Memory usage information not available (requires specific browser flags or versions).");
                        }
                        const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
                        const formatMB = (bytes) => (bytes / 1024 / 1024).toFixed(2) + ' MB';
                        return `Used: ${formatMB(usedJSHeapSize)}<br>Allocated: ${formatMB(totalJSHeapSize)}<br>Limit: ${formatMB(jsHeapSizeLimit)}`;
                    }
                },
                vibrate: {
                    description: "Vibrates the device (e.g., 'vibrate 500').",
                    execute: async (args) => {
                        if (!navigator.vibrate) {
                           throw new Error("Vibration API not supported.");
                        }
                        const duration = parseInt(args[0], 10);
                        if (isNaN(duration) || duration <= 0) {
                            throw new Error("Invalid duration. Provide milliseconds (e.g., vibrate 200).");
                        }
                        navigator.vibrate(duration);
                        return `Vibrating for ${duration}ms.`;
                    }
                },
                 // --- DANGEROUS COMMAND - Use with extreme caution ---
                nova: {
                    description: "Executes code/accesses properties in the parent window (Use cautiously!). Usage: nova propertyName or nova functionName()",
                    execute: async (args) => {
                        const commandStr = args.join(' '); // Reconstruct the argument string
                        if (!commandStr) {
                            throw new Error("No property or function specified.");
                        }

                        // WARNING: This accesses the parent window. Ensure you trust the parent context.
                        // Avoid if this CLI runs in untrusted environments.
                        if (!window.parent || window.parent === window) {
                             throw new Error("Cannot access parent window context.");
                        }

                        // Rudimentary parsing: Check if it looks like a function call
                        const isFunctionCall = commandStr.endsWith('()');
                        const targetName = isFunctionCall ? commandStr.slice(0, -2) : commandStr;

                        // Basic security check: Prevent accessing potentially sensitive top-level objects directly
                        // You might want to expand this blocklist/allowlist significantly
                        const blockedTargets = ['localStorage', 'sessionStorage', 'indexedDB', 'document', 'window', 'eval', 'Function'];
                        if (blockedTargets.includes(targetName) || targetName.startsWith('_')) {
                            throw new Error(`Access to '${targetName}' is restricted.`);
                        }

                        try {
                            // Access the property/function on the parent window
                            const target = window.parent[targetName];

                            let result;
                            if (isFunctionCall) {
                                if (typeof target === 'function') {
                                    // Execute the function - potential side effects!
                                    result = await target.call(window.parent); // Call in parent's context
                                } else {
                                    throw new Error(`'${targetName}' is not a function in the parent window.`);
                                }
                            } else {
                                // Access the property value
                                result = target;
                            }

                            // Format the result safely for display
                            return formatOutput(result);

                        } catch (err) {
                            // Catch errors during access or execution
                            throw new Error(`Execution failed: ${err.message}`);
                        }
                    }
                }
                // --- Add more commands here following the same structure ---
            };


            // --- Core Command Processor ---
            const processCommand = async () => {
                if (isProcessing) return; // Prevent multiple commands running concurrently

                const inputText = inputElement.value.trim();
                if (inputText === "") return; // Ignore empty input

                isProcessing = true;
                inputElement.disabled = true; // Disable input during processing

                // Add to history (if different from last command)
                if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== inputText) {
                    commandHistory.push(inputText);
                }
                historyIndex = commandHistory.length; // Reset history index

                // Clear input for next command
                inputElement.value = "";

                // Parse command and arguments
                const parts = inputText.match(/(?:[^\s"']+|"[^"]*"|'[^']*')+/g) || []; // Split by space, respecting quotes
                const commandName = parts[0]?.toLowerCase();
                const args = parts.slice(1).map(arg => arg.replace(/^["']|["']$/g, '')); // Remove surrounding quotes

                const command = commands[commandName];

                if (command) {
                    try {
                        const output = await command.execute(args);
                        // Only display output if the command returned something
                        if (output !== "" && output !== undefined && output !== null) {
                           displayOutput(inputText, formatOutput(output));
                        } else if (commandName !== 'clear') {
                           // Acknowledge commands that don't produce visible output (except clear)
                           displayOutput(inputText, `Command '${commandName}' executed.`);
                        }
                    } catch (error) {
                        displayError(inputText, error);
                    }
                } else if (commandName) {
                    displayError(inputText, `Command not found: ${commandName}. Type 'help' for available commands.`);
                }

                inputElement.disabled = false;
                inputElement.focus();
                isProcessing = false;
            };

            // --- Event Listeners ---
            inputElement.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    event.preventDefault(); // Prevent default newline behavior in input
                    processCommand();
                } else if (event.key === "ArrowUp") {
                    event.preventDefault(); // Prevent cursor moving to start
                    if (commandHistory.length > 0 && historyIndex > 0) {
                        historyIndex--;
                        inputElement.value = commandHistory[historyIndex];
                        // Move cursor to end
                        inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length);
                    }
                } else if (event.key === "ArrowDown") {
                     event.preventDefault(); // Prevent cursor moving to end
                    if (commandHistory.length > 0 && historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        inputElement.value = commandHistory[historyIndex];
                         // Move cursor to end
                        inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length);
                    } else if (historyIndex === commandHistory.length - 1) {
                        // If at the newest history item, pressing down clears the input
                        historyIndex++;
                        inputElement.value = "";
                    }
                }
                 // Add Tab for potential future autocompletion?
                 // else if (event.key === "Tab") { event.preventDefault(); // handleAutocomplete(); }
            });

            // Ensure focus on input when clicking anywhere in the output area
            outputElement.addEventListener('click', () => {
                 inputElement.focus();
            });


            // --- Initialization ---
            const initializeTerminal = () => {
                inputElement.focus();
                console.log("Nova CLI Enhanced Initialized.");
                // You could add a welcome message via displayOutput here if needed
            };

            // --- Start the application ---
            initializeTerminal();

        })(); // End of IIFE
    </script>
</body>
</html>
