<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Adjusted viewport -->
	<title>Enhanced Music App</title>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet"> <!-- Added weights -->
	<meta name="nova-icon" content="<svg version= '1.1 ' xmlns= 'http://www.w3.org/2000/svg ' xmlns:xlink= 'http://www.w3.org/1999/xlink ' width= '51 ' height= '49.50242 ' viewBox= '0,0,51,49.50242 '><g transform= 'translate(-214.5,-154.75988) '><g data-paper-data= '{&quot;isPaintingLayer&quot;:true} ' fill-rule= 'nonzero ' stroke-linejoin= 'miter ' stroke-miterlimit= '10 ' stroke-dasharray= ' ' stroke-dashoffset= '0 ' style= 'mix-blend-mode: normal '><path d= 'M214.5,177.00988c0,-14.08326 4.66674,-22.25 18.75,-22.25c14.08326,0 32.25,14.16674 32.25,28.25c0,14.08326 -11.89966,17.91973 -23.5,20.5c-20.43901,4.54627 -27.5,-12.41674 -27.5,-26.5z ' fill= '#6179ff ' stroke= 'none ' stroke-width= '0 ' stroke-linecap= 'butt '/><path d= 'M235.26333,186.05913l-2.26753,-13.83446l11.61789,0.96088l2.46892,13.36372 ' fill= 'none ' stroke= '#ffffff ' stroke-width= '3.5 ' stroke-linecap= 'round '/><path d= 'M227.30363,185.33244c0.21528,-2.60295 2.4999,-4.53854 5.10285,-4.32326c2.60295,0.21528 4.53854,2.49991 4.32326,5.10286c-0.21528,2.60295 -2.49991,4.53853 -5.10286,4.32325c-2.60295,-0.21528 -4.53853,-2.4999 -4.32325,-5.10285z ' fill= '#ffffff ' stroke= 'none ' stroke-width= '0 ' stroke-linecap= 'butt '/><path d= 'M239.88904,186.49159c0.20118,-2.43237 2.33609,-4.24111 4.76846,-4.03994c2.43237,0.20118 4.24111,2.33608 4.03994,4.76845c-0.20118,2.43237 -2.33608,4.24112 -4.76845,4.03995c-2.43237,-0.20118 -4.24112,-2.33609 -4.03995,-4.76846z ' fill= '#ffffff ' stroke= 'none ' stroke-width= '0 ' stroke-linecap= 'butt '/></g></g></svg>">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
	<style>
		:root {
			--main-color: #00ff50;
			/* Default accent color */
			--bg-color: #101010;
			--surface-color: #1f1f1f;
			--surface-transparent: #343434a0;
			/* Adjusted transparency */
			--text-primary: #ffffff;
			--text-secondary: #b3b3b3;
			--slider-track: #272727;
			--slider-thumb: #ffffff;
			--border-color: #80808054;
			--hover-bg: #2a2a2a;
			--active-color: var(--main-color);
			/* Active state color */
		}

		html {
			height: 100%;
			width: 100%;
			box-sizing: border-box;
			/* Better box model */
		}

		*,
		*:before,
		*:after {
			box-sizing: inherit;
		}

		body {
			height: 100%;
			font-family: "Poppins", sans-serif;
			margin: 0;
			background: var(--bg-color);
			color: var(--text-primary);
			overflow: hidden;
			/* Prevent body scrolling */
			display: flex;
			/* Use flex for main layout */
		}

		#loading-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.7);
			color: white;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.5rem;
			z-index: 10000;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s, visibility 0.3s;
		}

		#loading-overlay.visible {
			opacity: 1;
			visibility: visible;
		}

		.pagebody {
			display: flex;
			/* Changed display */
			flex-direction: column;
			/* Stack elements vertically initially */
			height: 100%;
			width: 100%;
			position: relative;
			/* Needed for absolute positioning of canvas/button */
		}

		.material-symbols-rounded {
			font-weight: 300;
			/* Adjusted weight */
			vertical-align: middle;
			/* Align icons better */
			font-size: 1.5rem;
			/* Default icon size */
			line-height: 1;
			/* Prevent extra space */
			user-select: none;
			/* Prevent icon selection */
		}

		.main-flex-container {
			display: flex;
			flex-direction: row;
			flex-grow: 1;
			/* Take remaining height */
			height: 100%;
			/* Ensure it fills */
			width: 100%;
			position: relative;
			/* Changed from absolute */
			z-index: 2;
		}

		#visualizerCanvas {
			/* Renamed for clarity */
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 1;
			pointer-events: none;
			/* Allow clicking through */
		}

		.player {
			display: flex;
			align-items: center;
			flex-direction: column;
			justify-content: center;
			flex-grow: 1;
			min-width: 300px;
			/* Minimum player width */
			padding: 1.5rem;
			/* Adjusted padding */
			gap: 1rem;
			/* Spacing between elements */
		}

		.details {
			display: flex;
			align-items: center;
			flex-direction: column;
			justify-content: center;
			width: 100%;
			text-align: center;
		}

		#baseimg {
			width: clamp(150px, 40%, 300px);
			/* Responsive image size */
			aspect-ratio: 1 / 1;
			object-fit: cover;
			/* Ensure image covers the area */
			border-radius: 8px;
			margin-bottom: 1rem;
			background-color: var(--surface-color);
			/* Placeholder bg */
			transition: box-shadow 0.5s ease;
		}

		.now-playing {
			font-size: 0.8rem;
			color: var(--text-secondary);
			margin-top: 0.5rem;
		}

		.track-name {
			font-size: 1.8rem;
			/* Adjusted size */
			font-weight: 500;
			text-align: center;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			width: 100%;
			max-width: 400px;
			/* Prevent excessive width */
			margin-bottom: 0.25rem;
		}

		.track-artist {
			font-size: 1rem;
			color: var(--text-secondary);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			width: 100%;
			max-width: 350px;
		}

		/* --- Controls --- */
		.controls {
			display: flex;
			flex-direction: column;
			align-items: center;
			width: 100%;
			max-width: 500px;
			/* Limit controls width */
			gap: 1rem;
		}

		.buttons {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: center;
			/* Center buttons */
			gap: 1.5rem;
			/* Spacing between main buttons */
			background: var(--surface-transparent);
			backdrop-filter: blur(10px);
			/* Smoother blur */
			border-radius: 3rem;
			padding: 0.5rem 1.5rem;
			width: auto;
			/* Fit content */
		}

		.control-button {
			/* Base class for control buttons */
			padding: 5px;
			opacity: 0.8;
			transition: opacity 0.2s, transform 0.2s, color 0.2s;
			cursor: pointer;
			color: var(--text-primary);
			background: none;
			border: none;
			line-height: 1;
		}

		.control-button:hover {
			opacity: 1.0;
		}

		.control-button:active {
			transform: scale(0.95);
		}

		.playpause-track {
			transform: scale(1.5);
			/* Make play/pause bigger */
			color: var(--main-color);
			/* Use accent color */
		}

		.playpause-track:hover {
			color: var(--main-color);
			/* Keep accent color on hover */
		}

		.loop-track.active,
		.shuffle-button.active {
			color: var(--main-color);
			opacity: 1;
		}

		.slider_container {
			width: 100%;
			display: flex;
			justify-content: center;
			/* Center slider content */
			align-items: center;
			gap: 10px;
			/* Space between elements */
		}

		.seek_slider,
		.volume_slider,
		.eq-slider,
		.balance-slider,
		.compressor-slider {
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			height: 6px;
			/* Thinner slider */
			border-radius: 3px;
			background: var(--slider-track);
			opacity: 0.8;
			transition: opacity .2s, background .2s;
			cursor: pointer;
			outline: none;
		}

		.seek_slider::-webkit-slider-thumb,
		.volume_slider::-webkit-slider-thumb,
		.eq-slider::-webkit-slider-thumb,
		.balance-slider::-webkit-slider-thumb,
		.compressor-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 14px;
			height: 14px;
			background: var(--slider-thumb);
			border-radius: 50%;
			transition: background 0.2s;
		}

		.seek_slider::-moz-range-thumb,
		.volume_slider::-moz-range-thumb,
		.eq-slider::-moz-range-thumb,
		.balance-slider::-moz-range-thumb,
		.compressor-slider::-moz-range-thumb {
			/* Firefox thumb */
			width: 14px;
			height: 14px;
			background: var(--slider-thumb);
			border-radius: 50%;
			border: none;
			transition: background 0.2s;
		}

		.seek_slider:hover,
		.volume_slider:hover,
		.eq-slider:hover,
		.balance-slider:hover,
		.compressor-slider:hover {
			opacity: 1.0;
		}

		/* Style thumb on interaction */
		.seek_slider:active::-webkit-slider-thumb,
		.volume_slider:active::-webkit-slider-thumb,
		.eq-slider:active::-webkit-slider-thumb,
		.balance-slider:active::-webkit-slider-thumb,
		.compressor-slider:active::-webkit-slider-thumb {
			background: var(--main-color);
		}

		.seek_slider:active::-moz-range-thumb,
		.volume_slider:active::-moz-range-thumb,
		.eq-slider:active::-moz-range-thumb,
		.balance-slider:active::-moz-range-thumb,
		.compressor-slider:active::-moz-range-thumb {
			background: var(--main-color);
		}

		.seek_slider {
			flex-grow: 1;
			/* Take available space */
			max-width: 400px;
			/* Limit max width */
		}

		.volume_slider {
			width: 120px;
			/* Fixed width for volume */
		}

		.current-time,
		.total-duration {
			font-size: 0.8rem;
			color: var(--text-secondary);
			min-width: 40px;
			/* Ensure space */
			text-align: center;
		}

		/* --- Queue Window --- */
		#queuewindow {
			display: flex;
			/* Use flex for internal layout */
			flex-direction: column;
			/* Stack elements vertically */
			width: 350px;
			/* Define a width */
			min-width: 300px;
			/* Minimum width */
			height: 100%;
			/* Fill height */
			margin: 1rem;
			border-radius: 1rem;
			padding: 1rem;
			background: var(--surface-transparent);
			backdrop-filter: blur(10px);
			overflow: hidden;
			/* Prevent content overflow */
		}

		.queuewinnav {
			display: flex;
			width: 100%;
			align-items: center;
			/* Align items vertically */
			justify-content: space-between;
			border-bottom: 1px solid var(--border-color);
			padding-bottom: 0.8rem;
			/* Increased padding */
			margin-bottom: 0.8rem;
			/* Space below nav */
			flex-shrink: 0;
			/* Prevent shrinking */
		}

		.queuenavtit {
			font-size: 1.3rem;
			/* Adjusted size */
			font-weight: 500;
		}

		.queuenavtit .now-playing-queue {
			/* Specific styling for queue count */
			font-size: 0.8rem;
			color: var(--text-secondary);
			display: block;
			/* Put on new line */
			font-weight: 300;
		}

		.queuewinnav .buttonside {
			display: flex;
			gap: 0.3rem;
			/* Space between buttons */
		}

		.queuewinnav .buttonside button {
			background: none;
			/* Transparent background */
			border: none;
			color: var(--text-secondary);
			/* Lighter color for secondary buttons */
			opacity: 0.8;
			border-radius: 50%;
			display: flex;
			/* Use flex for centering icon */
			align-items: center;
			justify-content: center;
			width: 36px;
			/* Fixed size */
			height: 36px;
			cursor: pointer;
			transition: background-color 0.2s, color 0.2s, opacity 0.2s;
		}

		.queuewinnav .buttonside button:hover {
			background: var(--hover-bg);
			color: var(--text-primary);
			opacity: 1;
		}

		.queuewinnav .buttonside button span {
			font-size: 1.4rem;
			font-weight: 300;
		}

		#queue-search {
			width: 100%;
			padding: 0.5rem 0.8rem;
			margin-bottom: 0.8rem;
			border-radius: 1rem;
			border: 1px solid var(--border-color);
			background-color: var(--surface-color);
			color: var(--text-primary);
			font-family: inherit;
			font-size: 0.9rem;
			flex-shrink: 0;
			/* Prevent shrinking */
		}

		#queue-search:focus {
			outline: none;
			border-color: var(--main-color);
		}

		#tracklist {
			flex-grow: 1;
			/* Allow tracklist to take remaining space */
			overflow-y: auto;
			/* Enable vertical scrolling */
			margin-right: -10px;
			/* Hide scrollbar visually trick */
			padding-right: 10px;
			/* Add padding back */
		}

		/* Custom Scrollbar */
		#tracklist::-webkit-scrollbar {
			width: 8px;
		}

		#tracklist::-webkit-scrollbar-track {
			background: transparent;
		}

		#tracklist::-webkit-scrollbar-thumb {
			background: var(--slider-track);
			border-radius: 4px;
		}

		#tracklist::-webkit-scrollbar-thumb:hover {
			background: #555;
		}

		.trackwid {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: space-between;
			align-items: center;
			padding: 0.5rem 0.6rem;
			/* Adjusted padding */
			background: transparent;
			/* Transparent bg */
			margin: 0.2rem 0;
			border-radius: 0.5rem;
			cursor: pointer;
			transition: background-color 0.2s;
			position: relative;
			/* For pseudo-element */
		}

		.trackwid:hover {
			background: var(--hover-bg);
		}

		.trackwid.playing {
			background: var(--surface-color);
			/* Highlight playing track */
			color: var(--main-color);
		}

		.trackwid.playing .ArtistName {
			color: var(--main-color);
			/* Make artist also accent color when playing */
			opacity: 0.8;
		}

		.trackwid.dragging {
			/* Style for item being dragged */
			opacity: 0.5;
			background: var(--main-color);
		}

		.trackwid.drag-over {
			/* Style for drop target */
			border-top: 2px solid var(--main-color);
		}

		.iconanddatdiv {
			display: flex;
			flex-direction: row;
			align-items: center;
			/* Vertically align icon and text */
			overflow: hidden;
			/* Prevent content spill */
			flex-grow: 1;
			/* Allow it to take space */
			margin-right: 5px;
			/* Space before close button */
		}

		.trackwid .icon {
			width: 35px;
			/* Fixed icon container size */
			height: 35px;
			flex-shrink: 0;
			/* Prevent icon shrinking */
			background: var(--surface-color);
			/* Use surface color */
			margin-right: 0.8rem;
			/* Space between icon and text */
			border-radius: 0.3rem;
			display: flex;
			/* Center icon */
			align-items: center;
			justify-content: center;
			text-shadow: 0 0 0.5rem rgba(0, 0, 0, 0.5);
			/* Softer shadow */
		}

		.trackwid .icon img {
			/* Style for album art in icon */
			width: 100%;
			height: 100%;
			object-fit: cover;
			border-radius: inherit;
		}

		.trackwid .icon span {
			font-size: 1.2rem;
			/* Adjust icon size */
		}

		.detailswid {
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
			/* Ensure single line */
		}

		.detailswid * {
			display: block;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			line-height: 1.3;
			/* Adjust line height */
		}

		.TrackName {
			/* No need for B tag */
			font-weight: 400;
			color: var(--text-primary);
			/* Ensure primary color */
			font-size: 0.95rem;
		}

		.ArtistName {
			color: var(--text-secondary);
			font-size: 0.8rem;
			margin-top: 2px;
			/* Small space */
		}

		.rmtrfrqu {
			display: none;
			/* Hide by default */
			cursor: pointer;
			color: var(--text-secondary);
			padding: 5px;
			/* Easier to click */
			border-radius: 50%;
			transition: color 0.2s, background-color 0.2s;
			flex-shrink: 0;
			/* Prevent shrinking */
			position: absolute;
			/* Position relative to parent */
			right: 5px;
			top: 50%;
			transform: translateY(-50%);
			/* Center vertically */
		}

		.trackwid:hover .rmtrfrqu {
			display: block;
			/* Show on hover */
		}

		.rmtrfrqu:hover {
			color: var(--text-primary);
			background-color: rgba(255, 255, 255, 0.1);
		}

		.add-track-button {
			position: absolute;
			bottom: 1rem;
			right: 1rem;
			border-radius: 50%;
			border: 0;
			width: 50px;
			height: 50px;
			padding: 0;
			/* Remove padding */
			line-height: 0;
			background: var(--main-color);
			/* Use accent color */
			color: var(--bg-color);
			/* Contrast color */
			cursor: pointer;
			z-index: 3;
			/* Above canvas/queue */
			display: flex;
			align-items: center;
			justify-content: center;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
			transition: transform 0.2s ease, background-color 0.2s;
		}

		.add-track-button:hover {
			transform: scale(1.1);
		}

		.add-track-button span {
			font-size: 1.8rem;
			font-weight: 400;
		}

		/* --- Initial Alert Dialog --- */
		#primaryalert {
			border: none;
			/* Remove default border */
			border-radius: 1rem;
			padding: 2rem;
			background: var(--surface-color);
			color: var(--text-primary);
			text-align: center;
			max-width: 350px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
		}

		#primaryalert::backdrop {
			/* Style backdrop */
			background: rgba(0, 0, 0, 0.6);
			backdrop-filter: blur(5px);
		}

		#primaryalert p {
			max-width: 250px;
			/* Adjust width */
			margin: 0 auto 1.5rem auto;
			/* Center and add bottom margin */
			color: var(--text-secondary);
			font-size: 0.9rem;
			line-height: 1.5;
		}

		#primaryalert .dialog-buttons {
			display: flex;
			flex-direction: column;
			/* Stack buttons */
			align-items: center;
			gap: 1rem;
			/* Space between buttons */
		}

		#primaryalert button,
		#primaryalert a {
			padding: 0.8rem 1.5rem;
			background: var(--hover-bg);
			border-radius: 2rem;
			border: none;
			cursor: pointer;
			color: var(--text-primary);
			font-size: 0.9rem;
			font-weight: 500;
			transition: background-color 0.2s, transform 0.1s;
			text-decoration: none;
			/* Remove underline from link */
			display: inline-flex;
			/* Align icon and text */
			align-items: center;
			gap: 0.5rem;
			min-width: 180px;
			/* Minimum width */
			justify-content: center;
		}

		#primaryalert button:hover,
		#primaryalert a:hover {
			background-color: var(--surface-transparent);
			/* Slightly lighter */
		}

		#primaryalert button:active,
		#primaryalert a:active {
			transform: scale(0.98);
		}

		#primaryalert .add-button-dialog {
			background: var(--main-color);
			color: var(--bg-color);
			font-weight: bold;
		}

		#primaryalert .add-button-dialog span {
			font-size: 1.2rem;
			/* Icon size in button */
		}

		/* --- Settings Sections --- */
		.settings-section {
			background: var(--surface-transparent);
			backdrop-filter: blur(10px);
			border-radius: 0.8rem;
			padding: 1rem;
			margin-top: 1rem;
			width: 100%;
			max-width: 500px;
			/* Match controls width */
		}

		.settings-section h3 {
			margin-top: 0;
			margin-bottom: 1rem;
			font-size: 1rem;
			font-weight: 500;
			color: var(--text-secondary);
			display: flex;
			justify-content: space-between;
			cursor: pointer;
		}

		.settings-section h3 span {
			/* Toggle icon */
			font-size: 1.2rem;
			transition: transform 0.3s ease;
		}

		.settings-section h3.collapsed span {
			transform: rotate(-90deg);
		}

		.settings-content {
			display: grid;
			gap: 0.8rem;
			max-height: 500px;
			/* Allow collapse animation */
			overflow: hidden;
			transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
		}

		.settings-content.collapsed {
			max-height: 0;
			opacity: 0;
			margin-top: 0;
			/* gap: 0; // Removing gap instantly causes layout jump, better to hide */
		}

		.setting-item {
			display: grid;
			grid-template-columns: 80px 1fr 40px;
			/* Label, Slider, Value */
			align-items: center;
			gap: 0.5rem;
			font-size: 0.85rem;
		}

		.setting-item label {
			text-align: right;
			color: var(--text-secondary);
			white-space: nowrap;
		}

		.setting-item .value-display {
			text-align: right;
			min-width: 30px;
			font-variant-numeric: tabular-nums;
			/* Keep numbers aligned */
		}

		.setting-item input[type="range"] {
			/* Target sliders inside */
			width: 100%;
			/* Fill grid space */
		}

		.setting-item input[type="checkbox"],
		.setting-item input[type="color"] {
			justify-self: start;
			/* Align checkbox/color left */
			grid-column: 2 / 4;
			/* Span across slider and value */
		}

		.setting-item input[type="color"] {
			width: 50px;
			height: 25px;
			border: none;
			padding: 0;
			border-radius: 4px;
			cursor: pointer;
		}

		#nerd-stats-content p {
			margin: 0 0 0.5rem 0;
			font-size: 0.9rem;
		}

		#nerd-stats-content p span {
			font-weight: 500;
			color: var(--text-primary);
			margin-left: 5px;
		}

		#freq-canvas {
			width: 100%;
			height: 80px;
			/* Adjust height as needed */
			background-color: var(--slider-track);
			border-radius: 4px;
			display: block;
			/* Remove extra space */
		}

		#visualizer-toggle {
			display: flex;
			gap: 0.5rem;
			align-items: center;
			margin-top: 0.5rem;
		}

		/* Utility Classes */
		.hidden {
			display: none !important;
		}
	</style>
</head>

<body>
	<div id="loading-overlay">Loading Audio...</div>
	<dialog id="primaryalert">
		<h2>Welcome!</h2>
		<p>Your queue is empty. Add some music to get started.</p>
		<div class="dialog-buttons">
			<button class="add-button-dialog" onclick="musicPlayer.openFiles()">
				<span class="material-symbols-rounded"> add </span> Add Songs </button>
			<a href="#" onclick="musicPlayer.scanForMusic(event)">
				<span class="material-symbols-rounded"> search </span> Scan All Folders </a>
			<button onclick="primaryalert.close()">
				<span class="material-symbols-rounded"> close </span> Close </button>
		</div>
	</dialog>
	<div class="pagebody">
		<canvas id="visualizerCanvas"></canvas> <!-- Changed ID -->
		<div class="main-flex-container">
			<div class="player">
				<div class="details">
					<img id="baseimg" src="" alt="Album Art">
					<div class="track-name">No Track Loaded</div>
					<div class="track-artist">Unknown Artist</div>
					<div class="now-playing">---</div>
				</div>
				<div class="controls">
					<div class="slider_container">
						<div class="current-time">00:00</div>
						<input type="range" min="0" max="100" value="0" class="seek_slider" oninput="musicPlayer.seeking()" onchange="musicPlayer.seekTo()">
						<div class="total-duration">00:00</div>
					</div>
					<div class="buttons">
						<button class="control-button loop-track" onclick="musicPlayer.toggleLoop()" title="Loop Mode (None)">
							<span class="material-symbols-rounded"> repeat </span>
						</button>
						<button class="control-button prev-track" onclick="musicPlayer.prevTrack()" title="Previous Track">
							<span class="material-symbols-rounded"> skip_previous </span>
						</button>
						<button class="control-button playpause-track" onclick="musicPlayer.playpauseTrack()" title="Play/Pause">
							<span class="material-symbols-rounded"> play_circle </span>
						</button>
						<button class="control-button next-track" onclick="musicPlayer.nextTrack()" title="Next Track">
							<span class="material-symbols-rounded"> skip_next </span>
						</button>
						<button class="control-button shuffle-button" onclick="musicPlayer.toggleShuffle()" title="Shuffle Queue">
							<span class="material-symbols-rounded"> shuffle </span>
						</button>
					</div>
					<div class="slider_container volume-container">
						<span class="material-symbols-rounded"> volume_down </span>
						<input type="range" min="0" max="100" value="80" class="volume_slider" oninput="musicPlayer.setVolume()" onchange="musicPlayer.setVolume()">
						<span class="material-symbols-rounded"> volume_up </span>
					</div>
				</div>
				<!-- Settings Sections -->
				<div class="settings-section">
					<h3 onclick="this.classList.toggle('collapsed'); document.getElementById('audio-settings-content').classList.toggle('collapsed');" title="Toggle Audio Settings"> Audio Settings <span class="material-symbols-rounded"> expand_more </span>
					</h3>
					<div id="audio-settings-content" class="settings-content">
						<!-- Preamp/Gain can be implicitly handled by volume or added if needed -->
						<div class="setting-item">
							<label for="balance-slider">Balance</label>
							<input type="range" id="balance-slider" class="balance-slider" min="-1" max="1" step="0.1" value="0" oninput="musicPlayer.setBalance(this.value)">
							<span class="value-display" id="balance-value">0.0</span>
						</div>
						<hr style="border-color: var(--border-color); grid-column: 1 / -1; margin: 0.5rem 0;">
						<div class="setting-item">
							<label>EQ Low</label>
							<input type="range" id="eq-low" class="eq-slider" min="-15" max="15" step="1" value="0" oninput="musicPlayer.setEQ('low', this.value)">
							<span class="value-display" id="eq-low-value">0 dB</span>
						</div>
						<div class="setting-item">
							<label>EQ Mid</label>
							<input type="range" id="eq-mid" class="eq-slider" min="-15" max="15" step="1" value="0" oninput="musicPlayer.setEQ('mid', this.value)">
							<span class="value-display" id="eq-mid-value">0 dB</span>
						</div>
						<div class="setting-item">
							<label>EQ High</label>
							<input type="range" id="eq-high" class="eq-slider" min="-15" max="15" step="1" value="0" oninput="musicPlayer.setEQ('high', this.value)">
							<span class="value-display" id="eq-high-value">0 dB</span>
						</div>
						<hr style="border-color: var(--border-color); grid-column: 1 / -1; margin: 0.5rem 0;">
						<div class="setting-item">
							<label for="compressor-toggle">Compressor</label>
							<input type="checkbox" id="compressor-toggle" onchange="musicPlayer.toggleCompressor(this.checked)">
						</div>
						<div class="setting-item compressor-controls hidden">
							<label>Threshold</label>
							<input type="range" id="compressor-threshold" class="compressor-slider" min="-100" max="0" step="1" value="-24" oninput="musicPlayer.setCompressor('threshold', this.value)">
							<span class="value-display" id="compressor-threshold-value">-24 dB</span>
						</div>
						<div class="setting-item compressor-controls hidden">
							<label>Ratio</label>
							<input type="range" id="compressor-ratio" class="compressor-slider" min="1" max="20" step="1" value="12" oninput="musicPlayer.setCompressor('ratio', this.value)">
							<span class="value-display" id="compressor-ratio-value">12</span>
						</div>
						<!-- Add Knee, Attack, Release if more detail needed -->
					</div>
				</div>
				<div class="settings-section">
					<h3 onclick="this.classList.toggle('collapsed'); document.getElementById('nerd-stats-content').classList.toggle('collapsed');" title="Toggle Nerd Stats"> Nerd Stats <span class="material-symbols-rounded"> expand_more </span>
					</h3>
					<div id="nerd-stats-content" class="settings-content collapsed">
						<p>Sample Rate: <span id="stat-sample-rate">N/A</span> Hz</p>
						<p>Audio Latency: <span id="stat-latency">N/A</span> s</p>
						<p>Channels: <span id="stat-channels">N/A</span></p>
						<p>Bitrate: <span id="stat-bitrate">N/A (Metadata)</span></p>
						<div id="visualizer-toggle">
							<label for="viz-type-select">Visualizer:</label>
							<select id="viz-type-select" onchange="musicPlayer.setVisualizerType(this.value)">
								<option value="bars" selected>Frequency Bars</option>
								<option value="particles">Audio Particles</option>
								<option value="off">Off</option>
							</select>
						</div>
						<canvas id="freq-canvas"></canvas>
					</div>
				</div>
				<div class="settings-section">
					<h3 onclick="this.classList.toggle('collapsed'); document.getElementById('theme-settings-content').classList.toggle('collapsed');" title="Toggle Theme Settings"> Theme <span class="material-symbols-rounded"> expand_more </span>
					</h3>
					<div id="theme-settings-content" class="settings-content collapsed">
						<div class="setting-item">
							<label for="accent-color-picker">Accent Color</label>
							<input type="color" id="accent-color-picker" value="#00ff50" oninput="musicPlayer.setAccentColor(this.value)">
						</div>
					</div>
				</div>
			</div>
			<div id="queuewindow">
				<div class="queuewinnav">
					<span class="queuenavtit">Queue <span class="now-playing-queue">(0 tracks)</span></span>
					<div class="buttonside">
						<button onclick="musicPlayer.saveQueue()" title="Save Queue Layout">
							<span class="material-symbols-rounded"> save </span>
						</button>
						<button onclick="musicPlayer.loadQueue()" title="Load Queue Layout">
							<span class="material-symbols-rounded"> folder_open </span>
						</button>
						<button onclick="musicPlayer.clearQueue()" title="Clear Queue">
							<span class="material-symbols-rounded"> delete_sweep </span>
						</button>
					</div>
				</div>
				<input type="search" id="queue-search" placeholder="Search queue..." oninput="musicPlayer.filterQueue(this.value)">
				<div id="tracklist">
					<!-- Tracks will be added here by JavaScript -->
					<div id="drop-indicator" class="hidden" style="height: 2px; background: var(--main-color); margin: 2px 0;"></div>
				</div>
			</div>
		</div>
		<button class="add-track-button" onclick="musicPlayer.openFiles()" title="Add Songs">
			<span class="material-symbols-rounded"> add </span>
		</button>
	</div>
	<script>
		class MusicPlayer {
			constructor() {
				// DOM Elements
				this.dom = {
					primaryAlert: document.getElementById('primaryalert'),
					loadingOverlay: document.getElementById('loading-overlay'),
					trackName: document.querySelector(".track-name"),
					trackArtist: document.querySelector(".track-artist"),
					baseImg: document.getElementById("baseimg"),
					playpauseBtn: document.querySelector(".playpause-track"),
					loopBtn: document.querySelector(".loop-track"),
					shuffleBtn: document.querySelector(".shuffle-button"),
					seekSlider: document.querySelector(".seek_slider"),
					volumeSlider: document.querySelector(".volume_slider"),
					currTime: document.querySelector(".current-time"),
					totalDuration: document.querySelector(".total-duration"),
					nowPlaying: document.querySelector(".now-playing"),
					nowPlayingQueue: document.querySelector(".now-playing-queue"),
					tracklistContainer: document.getElementById("tracklist"),
					queueSearch: document.getElementById('queue-search'),
					// Settings UI
					balanceSlider: document.getElementById('balance-slider'),
					balanceValue: document.getElementById('balance-value'),
					eqLow: document.getElementById('eq-low'),
					eqMid: document.getElementById('eq-mid'),
					eqHigh: document.getElementById('eq-high'),
					eqLowValue: document.getElementById('eq-low-value'),
					eqMidValue: document.getElementById('eq-mid-value'),
					eqHighValue: document.getElementById('eq-high-value'),
					compressorToggle: document.getElementById('compressor-toggle'),
					compressorThreshold: document.getElementById('compressor-threshold'),
					compressorRatio: document.getElementById('compressor-ratio'),
					compressorThresholdValue: document.getElementById('compressor-threshold-value'),
					compressorRatioValue: document.getElementById('compressor-ratio-value'),
					compressorControls: document.querySelectorAll('.compressor-controls'),
					accentColorPicker: document.getElementById('accent-color-picker'),
					// Stats UI
					statSampleRate: document.getElementById('stat-sample-rate'),
					statLatency: document.getElementById('stat-latency'),
					statChannels: document.getElementById('stat-channels'),
					statBitrate: document.getElementById('stat-bitrate'),
					// Visualizer UI
					visualizerCanvas: document.getElementById('visualizerCanvas'),
					freqCanvas: document.getElementById('freq-canvas'),
					vizTypeSelect: document.getElementById('viz-type-select'),
				};
				this.visualizerCtx = this.dom.visualizerCanvas.getContext('2d');
				this.freqCtx = this.dom.freqCanvas.getContext('2d');
				this.currentReqID = null; // For file requests
				this.myWindow = window.parent?.myWindow; // Access parent window context if available
				// State
				this.trackList = []; // Array<{id: string, name: string, artist: string, path: string, // base64 or identifier albumArt?: string, // base64 data URL bitrate?: number }>
				this.originalOrderTrackList = []; // For un-shuffling
				this.currentIndex = -1;
				this.isPlaying = false;
				this.isSeeking = false; // Flag to prevent seekUpdate during manual seek
				this.updateTimer = null;
				this.loopMode = 'none'; // 'none', 'all', 'one'
				this.isShuffled = false;
				this.visualizerType = 'bars'; // 'bars', 'particles', 'off'
				this.animationFrameId = null;
				this.particlesArray = [];
				this.baseNumParticles = 50;
				// Web Audio API Stuff
				this.audioContext = null;
				this.audioElement = document.createElement('audio');
				this.audioSource = null;
				this.gainNode = null; // Master Gain (Volume)
				this.stereoPannerNode = null; // Balance
				this.eqNodes = {
					low: null,
					mid: null,
					high: null
				}; // EQ Bands
				this.compressorNode = null; // Compressor
				this.analyserNode = null; // For visualization and stats
				this.analyserDataArray = null;
				this.analyserBufferLength = 0;
				// Drag and Drop State
				this.draggedItem = null;
				this.dragOverItem = null;
				this.dropIndicator = document.getElementById('drop-indicator');
				this.colorThief = new ColorThief();
				this._initialize();
			}
			_initialize() {
				this._setupEventListeners();
				this._loadSettings();
				this._resizeCanvas(); // Initial canvas sizing
				// Check if there's a saved queue structure (metadata only)
				const savedQueueMeta = localStorage.getItem('musicQueueMeta');
				if(savedQueueMeta) {
					console.log("Found saved queue metadata. Implement logic to prompt user to re-select files based on this metadata if desired.");
					// Example: You could display the list and mark files as "missing"
					// For now, we just show the initial dialog if no files are loaded *yet*.
					// this.trackList = JSON.parse(savedQueueMeta); // Don't assign yet, needs paths
					// this.renderQueue(); // Render placeholder queue
				}
				// Show initial dialog if queue is truly empty after loading/checking
				if(this.trackList.length === 0) {
					this.dom.primaryAlert.showModal();
				}
				console.log("Music Player Initialized");
			}
			_setupEventListeners() {
				window.addEventListener('resize', () => this._resizeCanvas());
				this.audioElement.addEventListener('loadedmetadata', () => this._onTrackLoaded());
				this.audioElement.addEventListener('ended', () => this._onTrackEnded());
				this.audioElement.addEventListener('error', (e) => this._handleAudioError(e));
				// Queue drag and drop
				this.dom.tracklistContainer.addEventListener('dragstart', (e) => this._handleDragStart(e));
				this.dom.tracklistContainer.addEventListener('dragover', (e) => this._handleDragOver(e));
				this.dom.tracklistContainer.addEventListener('dragleave', (e) => this._handleDragLeave(e));
				this.dom.tracklistContainer.addEventListener('drop', (e) => this._handleDrop(e));
				this.dom.tracklistContainer.addEventListener('dragend', (e) => this._handleDragEnd(e));
				// Keyboard shortcuts
				document.addEventListener('keydown', (e) => this._handleKeyDown(e));
				// File loading via parent window message (if applicable)
				window.addEventListener('message', async (event) => {
					if(event.data.action === 'loadlocalfile' && event.data.id === this.myWindow?.windowID && this.currentReqID === event.data.reqid) {
						console.log("Player received file:", event.data.returned);
						if(window.parent && typeof window.parent.getFileById === 'function') {
							try {
								const fileData = await window.parent.getFileById(event.data.returned);
								if(fileData && fileData.content) {
									this.readFileContent(fileData.content, fileData.fileName);
								} else {
									console.error("Received file data is invalid:", fileData);
									this._showToast("Failed to load file data.", "error");
								}
							} catch (err) {
								console.error("Error getting file content:", err);
								this._showToast("Error retrieving file.", "error");
							}
						} else {
							console.warn("Parent window context or getFileById function not available.");
						}
						this.currentReqID = null; // Reset request ID
					}
				});
				// Settings Toggles
				document.querySelectorAll('.settings-section h3').forEach(header => {
					header.addEventListener('click', () => {
						const content = header.nextElementSibling;
						if(content) {
							// Toggle internal class on header for icon rotation state if needed
						}
					});
				});
			}
			_initAudioContext() {
				if(this.audioContext && this.audioContext.state !== 'closed') return; // Already initialized or reusable
				try {
					this.audioContext = new(window.AudioContext || window.webkitAudioContext)();
					// Create Nodes
					this.audioSource = this.audioContext.createMediaElementSource(this.audioElement);
					this.gainNode = this.audioContext.createGain();
					this.stereoPannerNode = this.audioContext.createStereoPanner();
					this.eqNodes.low = this.audioContext.createBiquadFilter();
					this.eqNodes.mid = this.audioContext.createBiquadFilter();
					this.eqNodes.high = this.audioContext.createBiquadFilter();
					this.compressorNode = this.audioContext.createDynamicsCompressor();
					this.analyserNode = this.audioContext.createAnalyser();
					// Configure Nodes
					this.eqNodes.low.type = 'lowshelf';
					this.eqNodes.low.frequency.value = 320; // Adjust frequency as needed
					this.eqNodes.mid.type = 'peaking';
					this.eqNodes.mid.frequency.value = 1000;
					this.eqNodes.mid.Q.value = 0.7; // Adjust Q factor
					this.eqNodes.high.type = 'highshelf';
					this.eqNodes.high.frequency.value = 3200;
					this.analyserNode.fftSize = 512; // Moderate detail for visualizer
					this.analyserBufferLength = this.analyserNode.frequencyBinCount;
					this.analyserDataArray = new Uint8Array(this.analyserBufferLength);
					// Connect Nodes (Audio Graph)
					this.audioSource.connect(this.stereoPannerNode).connect(this.eqNodes.low).connect(this.eqNodes.mid).connect(this.eqNodes.high).connect(this.compressorNode) // Compressor before master gain
						.connect(this.gainNode).connect(this.analyserNode) // Analyse final output before destination
						.connect(this.audioContext.destination);
					console.log("Audio Context and graph initialized.");
					this._updateAudioStats(); // Update stats display
					this._loadSettings(); // Apply saved settings to the new nodes
				} catch (e) {
					console.error("Error initializing Audio Context:", e);
					this._showToast("Web Audio API not supported or failed to initialize.", "error");
				}
			}
			_resumeAudioContext() {
				if(this.audioContext && this.audioContext.state === 'suspended') {
					this.audioContext.resume().then(() => {
						console.log("AudioContext resumed successfully.");
						this._updateAudioStats();
					}).catch(err => {
						console.error("Failed to resume AudioContext:", err);
						// Maybe show a button to the user to explicitly resume
					});
				} else if(!this.audioContext) {
					this._initAudioContext(); // Initialize if it doesn't exist
				}
			}
			_updateAudioStats() {
				if(!this.audioContext) return;
				this.dom.statSampleRate.textContent = this.audioContext.sampleRate.toLocaleString();
				this.dom.statLatency.textContent = (this.audioContext.baseLatency + this.audioContext.outputLatency).toFixed(4);
				this.dom.statChannels.textContent = this.audioContext.destination.channelCount;
			}
			_updateBitrateStat(bitrate) {
				this.dom.statBitrate.textContent = bitrate ? `${Math.round(bitrate / 1000)} kbps (Metadata)` : 'N/A (Metadata)';
			}
			// --- Settings Management ---
			_loadSettings() {
				const volume = localStorage.getItem('musicPlayerVolume') ?? 80;
				const accentColor = localStorage.getItem('musicPlayerAccentColor') ?? '#00ff50';
				const loopMode = localStorage.getItem('musicPlayerLoopMode') ?? 'none';
				const isShuffled = localStorage.getItem('musicPlayerIsShuffled') === 'true';
				const balance = parseFloat(localStorage.getItem('musicPlayerBalance') ?? 0);
				const eqLowGain = parseFloat(localStorage.getItem('musicPlayerEqLow') ?? 0);
				const eqMidGain = parseFloat(localStorage.getItem('musicPlayerEqMid') ?? 0);
				const eqHighGain = parseFloat(localStorage.getItem('musicPlayerEqHigh') ?? 0);
				const compressorEnabled = localStorage.getItem('musicPlayerCompressorEnabled') === 'true';
				const compressorThreshold = parseFloat(localStorage.getItem('musicPlayerCompressorThreshold') ?? -24);
				const compressorRatio = parseFloat(localStorage.getItem('musicPlayerCompressorRatio') ?? 12);
				// Apply Volume
				this.dom.volumeSlider.value = volume;
				if(this.gainNode) this.gainNode.gain.value = volume / 100;
				// Apply Accent Color
				this.setAccentColor(accentColor); // Use the method to apply and update UI
				this.dom.accentColorPicker.value = accentColor;
				// Apply Loop Mode
				this.loopMode = loopMode;
				this._updateLoopButton();
				// Apply Shuffle State (Visual Only - Actual shuffle happens on load/toggle)
				this.isShuffled = isShuffled;
				this.dom.shuffleBtn.classList.toggle('active', this.isShuffled);
				// Apply Audio Processing Settings
				// Balance
				this.dom.balanceSlider.value = balance;
				this.dom.balanceValue.textContent = balance.toFixed(1);
				if(this.stereoPannerNode) this.stereoPannerNode.pan.value = balance;
				// EQ
				this.dom.eqLow.value = eqLowGain;
				this.dom.eqMid.value = eqMidGain;
				this.dom.eqHigh.value = eqHighGain;
				this.dom.eqLowValue.textContent = `${eqLowGain} dB`;
				this.dom.eqMidValue.textContent = `${eqMidGain} dB`;
				this.dom.eqHighValue.textContent = `${eqHighGain} dB`;
				if(this.eqNodes.low) this.eqNodes.low.gain.value = eqLowGain;
				if(this.eqNodes.mid) this.eqNodes.mid.gain.value = eqMidGain;
				if(this.eqNodes.high) this.eqNodes.high.gain.value = eqHighGain;
				// Compressor
				this.dom.compressorToggle.checked = compressorEnabled;
				this.dom.compressorThreshold.value = compressorThreshold;
				this.dom.compressorRatio.value = compressorRatio;
				this.dom.compressorThresholdValue.textContent = `${compressorThreshold} dB`;
				this.dom.compressorRatioValue.textContent = compressorRatio;
				this.dom.compressorControls.forEach(el => el.classList.toggle('hidden', !compressorEnabled));
				this._applyCompressorState(compressorEnabled); // Connect/disconnect node
				if(this.compressorNode) {
					this.compressorNode.threshold.value = compressorThreshold;
					this.compressorNode.ratio.value = compressorRatio;
					// Set default knee, attack, release if needed
					// this.compressorNode.knee.value = 30;
					// this.compressorNode.attack.value = 0.003;
					// this.compressorNode.release.value = 0.25;
				}
			}
			setVolume() {
				const volume = this.dom.volumeSlider.value;
				if(this.gainNode) {
					this.gainNode.gain.setTargetAtTime(volume / 100, this.audioContext.currentTime, 0.01); // Smoother transition
				}
				localStorage.setItem('musicPlayerVolume', volume);
				this._updateSliderBg(this.dom.volumeSlider);
			}
			setAccentColor(color) {
				document.documentElement.style.setProperty('--main-color', color);
				this.dom.accentColorPicker.value = color; // Ensure picker reflects change
				localStorage.setItem('musicPlayerAccentColor', color);
				this._redrawVisualizer(); // Redraw with new color if needed
			}
			setBalance(value) {
				const balance = parseFloat(value);
				if(this.stereoPannerNode) {
					this.stereoPannerNode.pan.setTargetAtTime(balance, this.audioContext.currentTime, 0.01);
				}
				this.dom.balanceValue.textContent = balance.toFixed(1);
				localStorage.setItem('musicPlayerBalance', balance);
			}
			setEQ(band, value) {
				const gain = parseFloat(value);
				if(this.eqNodes[band]) {
					this.eqNodes[band].gain.setTargetAtTime(gain, this.audioContext.currentTime, 0.01);
				}
				document.getElementById(`eq-${band}-value`).textContent = `${gain} dB`;
				localStorage.setItem(`musicPlayerEq${band.charAt(0).toUpperCase() + band.slice(1)}`, gain); // e.g., musicPlayerEqLow
			}
			toggleCompressor(enabled) {
				this._applyCompressorState(enabled);
				this.dom.compressorControls.forEach(el => el.classList.toggle('hidden', !enabled));
				localStorage.setItem('musicPlayerCompressorEnabled', enabled);
			}
			setCompressor(param, value) {
				const val = parseFloat(value);
				if(this.compressorNode && this.compressorNode[param]) {
					this.compressorNode[param].setTargetAtTime(val, this.audioContext.currentTime, 0.01);
				}
				document.getElementById(`compressor-${param}-value`).textContent = param === 'threshold' ? `${val} dB` : val;
				localStorage.setItem(`musicPlayerCompressor${param.charAt(0).toUpperCase() + param.slice(1)}`, val);
			}
			_applyCompressorState(enabled) {
				if(!this.audioContext || !this.compressorNode) return;
				// Disconnect compressor temporarily to avoid glitches
				// Find the node *before* the compressor (in this graph, it's the last EQ node)
				const nodeBeforeCompressor = this.eqNodes.high;
				// Find the node *after* the compressor (in this graph, it's the master gain node)
				const nodeAfterCompressor = this.gainNode;
				try {
					nodeBeforeCompressor.disconnect(this.compressorNode);
					this.compressorNode.disconnect(nodeAfterCompressor);
				} catch (e) {
					/* Ignore errors if not connected */ }
				if(enabled) {
					// Connect through compressor: Before -> Compressor -> After
					nodeBeforeCompressor.connect(this.compressorNode);
					this.compressorNode.connect(nodeAfterCompressor);
					console.log("Compressor Enabled");
				} else {
					// Bypass compressor: Before -> After
					nodeBeforeCompressor.connect(nodeAfterCompressor);
					console.log("Compressor Disabled");
				}
			}
			// --- File Handling & Queue Management ---
			openFiles() {
				// This uses the parent window interaction logic from the original code
				if(window.parent && typeof window.parent.genUID === 'function' && typeof window.parent.openlaunchprotocol === 'function') {
					this.currentReqID = window.parent.genUID();
					let appIdToOpen = window.parent.fileTypeAssociations?.['file']?.[0] || null; // Safer access
					if(appIdToOpen && this.myWindow) {
						window.parent.openlaunchprotocol(appIdToOpen, {
							"action": "opn",
							"args": ["--type=audio/*"]
						}, this.currentReqID, this.myWindow.windowID);
						this.dom.primaryAlert.close();
					} else {
						console.error("Cannot open file dialog: Parent context, window ID, or file association missing.");
						this._showToast("Cannot open file dialog.", "error");
					}
				} else {
					// Fallback for standalone testing (won't work in sandbox)
					const input = document.createElement('input');
					input.type = 'file';
					input.accept = 'audio/*';
					input.multiple = true;
					input.onchange = (e) => {
						for(const file of e.target.files) {
							const reader = new FileReader();
							reader.onload = (event) => {
								this.readFileContent(event.target.result, file.name);
							};
							reader.readAsDataURL(file);
						}
						this.dom.primaryAlert.close();
					};
					input.click();
					console.warn("Using fallback file input. Parent window interaction preferred.");
				}
			}
			readFileContent(base64Url, fileName = 'Unknown Title') {
				this.dom.loadingOverlay.classList.add('visible');
				const uniqueId = `track_${Date.now()}_${Math.random().toString(16).slice(2)}`;
				// Use jsmediatags to read metadata
				jsmediatags.read(base64Url, {
					onSuccess: (tag) => {
						const metadata = tag.tags;
						const trackName = metadata.title || fileName.replace(/\.[^/.]+$/, ""); // Fallback to filename without extension
						const artistName = metadata.artist || 'Unknown Artist';
						const albumName = metadata.album || 'Unknown Album';
						let albumArt = null;
						let dominantColor = '#333'; // Default color
						if(metadata.picture && metadata.picture.data) {
							try {
								const base64String = this._arrayBufferToBase64(metadata.picture.data);
								albumArt = `data:${metadata.picture.format};base64,${base64String}`;
								// Get dominant color async (don't block adding track)
								this._getDominantColorAsync(albumArt).then(color => {
									// Find the track element later and update maybe? Or store color with track data.
								});
							} catch (e) {
								console.error("Error processing album art", e)
							}
						}
						const newTrack = {
							id: uniqueId,
							name: trackName,
							artist: artistName,
							album: albumName, // Store album name
							path: base64Url, // Store the full Data URL
							albumArt: albumArt,
							// Bitrate often requires deeper analysis not available here easily
							// bitrate: metadata.bitrate // Example if tag provides it
						};
						// Avoid duplicates based on name/artist/album? Or allow? Currently allow.
						this.trackList.push(newTrack);
						if(!this.isShuffled) {
							this.originalOrderTrackList.push({
								...newTrack
							}); // Keep original order sync'd
						}
						this.renderQueue();
						// Auto-play if it's the first track added
						if(this.trackList.length === 1 && this.currentIndex === -1) {
							this.loadTrack(0);
						}
						this.dom.loadingOverlay.classList.remove('visible');
					},
					onError: (error) => {
						console.error("Error reading metadata for:", fileName, error);
						// Add track with default metadata even if tags fail
						const uniqueIdOnError = `track_${Date.now()}_${Math.random().toString(16).slice(2)}`;
						const trackNameOnError = fileName.replace(/\.[^/.]+$/, "");
						const newTrackOnError = {
							id: uniqueIdOnError,
							name: trackNameOnError,
							artist: 'Unknown Artist',
							album: 'Unknown Album',
							path: base64Url,
							albumArt: null,
						};
						this.trackList.push(newTrackOnError);
						if(!this.isShuffled) {
							this.originalOrderTrackList.push({
								...newTrackOnError
							});
						}
						this.renderQueue();
						if(this.trackList.length === 1 && this.currentIndex === -1) {
							this.loadTrack(0);
						}
						this.dom.loadingOverlay.classList.remove('visible');
						this._showToast(`Metadata error for ${fileName}`, "warning");
					}
				});
			}
			_arrayBufferToBase64(buffer) {
				let binary = '';
				const bytes = new Uint8Array(buffer);
				const len = bytes.byteLength;
				for(let i = 0; i < len; i++) {
					binary += String.fromCharCode(bytes[i]);
				}
				return window.btoa(binary);
			}
			async _getDominantColorAsync(imageUrl) {
				return new Promise((resolve, reject) => {
					if(!imageUrl) {
						resolve("#333333"); // Default dark grey
						return;
					}
					const image = new Image();
					image.crossOrigin = 'Anonymous';
					image.src = imageUrl;
					image.onload = () => {
						try {
							const dominantColor = this.colorThief.getColor(image);
							const hexColor = this._rgbToHex(dominantColor[0], dominantColor[1], dominantColor[2]);
							resolve(hexColor);
						} catch (error) {
							console.error("ColorThief error:", error);
							resolve("#333333"); // Fallback on error
						}
					};
					image.onerror = (err) => {
						console.error("Image load error for ColorThief:", err);
						resolve("#333333"); // Fallback on error
					};
				});
			}
			_rgbToHex(r, g, b) {
				return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
			}
			scanForMusic(event) {
				event.preventDefault(); // Prevent default link behavior if called from <a>
				this.dom.primaryAlert.close();
				// Uses parent window interaction logic
				if(window.parent && typeof window.parent.memory?.tree === 'object') {
					this._showToast("Scanning folders... This may take a while.", "info");
					const musicExtensions = ['mp3', 'wav', 'flac', 'ogg', 'm4a', 'aac']; // Include more common formats
					let filesFound = 0;
					const isMusicFile = (fileName) => {
						const extension = fileName.split('.').pop()?.toLowerCase(); // Optional chaining
						return extension ? musicExtensions.includes(extension) : false;
					};
					// Use a more robust async iteration
					const scan = async (folderData, currentPath = '') => {
						for(const key in folderData) {
							const item = folderData[key];
							const isDirectory = key.endsWith('/');
							const itemName = isDirectory ? key.slice(0, -1) : key; // Get name without '/'
							if(isDirectory && item && typeof item === 'object') {
								// Recurse into subdirectory
								await scan(item, `${currentPath}${itemName}/`);
							} else if(!isDirectory && item && typeof item === 'object' && item.id && isMusicFile(itemName)) {
								// Check if file content exists in pool (safer access)
								const fileContent = window.parent.memory.contentpool?.[item.id];
								if(fileContent) {
									await new Promise(resolve => setTimeout(resolve, 0)); // Yield to prevent blocking UI thread
									this.readFileContent(fileContent, itemName);
									filesFound++;
								} else {
									console.warn(`Content for music file ${currentPath}${itemName} (ID: ${item.id}) not found in contentpool.`);
								}
							}
						}
					};
					// Start scanning from the root
					scan(window.parent.memory.tree).then(() => {
						this.dom.loadingOverlay.classList.remove('visible');
						if(filesFound === 0) {
							this._showToast("No music files found during scan.", "warning");
							// Optionally re-open the dialog if queue is still empty
							if(this.trackList.length === 0) {
								this.dom.primaryAlert.showModal();
							}
						} else {
							this._showToast(`Scan complete. Added ${filesFound} tracks.`, "success");
						}
					}).catch(err => {
						console.error("Error during scan:", err);
						this.dom.loadingOverlay.classList.remove('visible');
						this._showToast("An error occurred during the scan.", "error");
					});
				} else {
					console.error("Cannot scan: Parent context or memory tree not available.");
					this._showToast("Folder scanning not available in this context.", "error");
				}
			}
			renderQueue() {
				this.dom.tracklistContainer.innerHTML = ''; // Clear existing list (simple approach)
				this.dropIndicator = document.getElementById('drop-indicator'); // Re-select after clearing
				if(!this.dropIndicator) { // Create if it doesn't exist
					this.dropIndicator = document.createElement('div');
					this.dropIndicator.id = 'drop-indicator';
					this.dropIndicator.className = 'hidden';
					this.dropIndicator.style.cssText = 'height: 2px; background: var(--main-color); margin: 1px 0; pointer-events: none;';
					// Append somewhere logical, maybe start of tracklist? Or handle positioning in dragover.
					// For simplicity, we'll just ensure it exists. Positioning handled in dragover.
				}
				const searchTerm = this.dom.queueSearch.value.toLowerCase();
				this.trackList.forEach((track, index) => {
					// Filter logic
					if(searchTerm && !track.name.toLowerCase().includes(searchTerm) && !track.artist.toLowerCase().includes(searchTerm)) {
						return; // Skip rendering this track
					}
					const trackWid = document.createElement('div');
					trackWid.className = 'trackwid';
					trackWid.dataset.index = index; // Store index for easy lookup
					trackWid.dataset.id = track.id; // Store unique ID
					trackWid.draggable = true; // Make item draggable
					if(index === this.currentIndex) {
						trackWid.classList.add('playing');
					}
					trackWid.onclick = (event) => {
						// Prevent triggering play if clicking the remove button
						if(event.target.classList.contains('rmtrfrqu')) return;
						this.loadTrack(index);
					};
					const iconanddatdiv = document.createElement('div');
					iconanddatdiv.className = "iconanddatdiv";
					const iconDiv = document.createElement('div');
					iconDiv.className = 'icon';
					if(track.albumArt) {
						const img = document.createElement('img');
						img.src = track.albumArt;
						img.alt = 'Art';
						img.onerror = () => { // Fallback if album art fails to load
							img.remove();
							const musicNoteSpan = document.createElement('span');
							musicNoteSpan.className = 'material-symbols-rounded';
							musicNoteSpan.textContent = 'music_note';
							iconDiv.appendChild(musicNoteSpan);
						};
						iconDiv.appendChild(img);
					} else {
						const musicNoteSpan = document.createElement('span');
						musicNoteSpan.className = 'material-symbols-rounded';
						musicNoteSpan.textContent = 'music_note';
						iconDiv.appendChild(musicNoteSpan);
					}
					const detailsWid = document.createElement('div');
					detailsWid.className = 'detailswid';
					const trackNameElement = document.createElement('div'); // Use div, style with CSS
					trackNameElement.className = 'TrackName';
					trackNameElement.textContent = track.name || 'Unnamed Track'; // Use internal property
					trackNameElement.title = track.name || 'Unnamed Track'; // Tooltip for long names
					const artistName = document.createElement('span');
					artistName.className = 'ArtistName';
					artistName.textContent = track.artist || 'Unknown Artist';
					artistName.title = track.artist || 'Unknown Artist';
					detailsWid.appendChild(trackNameElement);
					detailsWid.appendChild(artistName);
					const closeSpan = document.createElement('span');
					closeSpan.className = 'material-symbols-rounded rmtrfrqu';
					closeSpan.textContent = 'close';
					closeSpan.title = 'Remove from queue';
					closeSpan.onclick = (e) => {
						e.stopPropagation(); // Prevent trackwid click
						this.removeTrack(index);
					};
					iconanddatdiv.appendChild(iconDiv);
					iconanddatdiv.appendChild(detailsWid);
					trackWid.appendChild(iconanddatdiv);
					trackWid.appendChild(closeSpan);
					this.dom.tracklistContainer.appendChild(trackWid);
				});
				// Update queue count
				const visibleTracks = this.dom.tracklistContainer.children.length - (this.dom.tracklistContainer.contains(this.dropIndicator) ? 1 : 0); // Exclude indicator if present
				this.dom.nowPlayingQueue.textContent = `(${visibleTracks} / ${this.trackList.length} tracks)`;
				// Add empty state message if needed (optional)
				if(this.trackList.length === 0) {
					const emptyMsg = document.createElement('p');
					emptyMsg.textContent = "Add songs using the '+' button or File menu.";
					emptyMsg.style.textAlign = 'center';
					emptyMsg.style.color = 'var(--text-secondary)';
					emptyMsg.style.marginTop = '2rem';
					this.dom.tracklistContainer.appendChild(emptyMsg);
				}
			}
			filterQueue() {
				this.renderQueue(); // Re-render the queue with the current filter
			}
			removeTrack(indexToRemove) {
				if(indexToRemove < 0 || indexToRemove >= this.trackList.length) return;
				const removedTrackId = this.trackList[indexToRemove].id;
				this.trackList.splice(indexToRemove, 1);
				// Also remove from original order list if it exists there
				const originalIndex = this.originalOrderTrackList.findIndex(t => t.id === removedTrackId);
				if(originalIndex > -1) {
					this.originalOrderTrackList.splice(originalIndex, 1);
				}
				if(this.trackList.length === 0) {
					// Queue is now empty
					this._resetPlayerUI(); // Reset player display
					this.currentIndex = -1;
					if(this.isPlaying) this.pauseTrack(); // Stop playback
					this.audioElement.src = ''; // Clear audio source
				} else if(indexToRemove === this.currentIndex) {
					// Removed the currently playing track
					if(this.isPlaying) {
						// Load the next track (or the new track at the same index if not last)
						const nextIndex = indexToRemove >= this.trackList.length ? 0 : indexToRemove;
						this.loadTrack(nextIndex);
					} else {
						// Just update the index if paused
						this.currentIndex = indexToRemove >= this.trackList.length ? 0 : indexToRemove;
						// No need to load, just adjust index, UI will reflect on next play/load
					}
					// Update UI immediately for the removed track info if needed
				} else if(indexToRemove < this.currentIndex) {
					// Removed a track BEFORE the current one, adjust index
					this.currentIndex--;
				}
				// If removed *after* current, index remains correct.
				this.renderQueue(); // Update the visual list
			}
			clearQueue() {
				if(confirm("Are you sure you want to clear the entire queue?")) {
					this.trackList = [];
					this.originalOrderTrackList = [];
					this.isShuffled = false; // Reset shuffle state
					this.dom.shuffleBtn.classList.remove('active');
					this._resetPlayerUI();
					this.currentIndex = -1;
					if(this.isPlaying) this.pauseTrack();
					this.audioElement.src = '';
					this.renderQueue();
					// Optionally show the initial dialog again
					// this.dom.primaryAlert.showModal();
				}
			}
			saveQueue() {
				// SECURITY/STORAGE NOTE: Saving base64 data in localStorage is risky (size limits, performance).
				// It's safer to save only metadata and require users to re-select files.
				if(this.trackList.length === 0) {
					this._showToast("Queue is empty, nothing to save.", "info");
					return;
				}
				const queueMetadata = this.trackList.map(track => ({
					name: track.name,
					artist: track.artist,
					album: track.album,
					// Include filename or a unique identifier if available from original file handle
				}));
				try {
					localStorage.setItem('musicQueueMeta', JSON.stringify(queueMetadata));
					this._showToast("Queue layout saved (metadata only).", "success");
				} catch (e) {
					console.error("Failed to save queue metadata to localStorage:", e);
					this._showToast("Failed to save queue layout.", "error");
				}
			}
			loadQueue() {
				const savedQueueMeta = localStorage.getItem('musicQueueMeta');
				if(savedQueueMeta) {
					if(confirm("Loading a saved queue will replace the current one and require you to re-select the audio files. Continue?")) {
						try {
							const queueMetadata = JSON.parse(savedQueueMeta);
							// Clear current queue
							this.trackList = [];
							this.originalOrderTrackList = [];
							this.currentIndex = -1;
							if(this.isPlaying) this.pauseTrack();
							this.audioElement.src = '';
							this._resetPlayerUI();
							// TODO: Enhance this - Display the list and prompt the user to locate each file.
							// This is complex UI work. For now, clear the queue and inform the user.
							alert("Queue structure loaded. Please add the corresponding audio files again.");
							// Example of setting up placeholders:
							// this.trackList = queueMetadata.map((meta, i) => ({ ...meta, id: `placeholder_${i}`, path: null, albumArt: null }));
							// this.renderQueue(); // Render the placeholder queue
							this.renderQueue(); // Renders empty queue for now
							this._showToast("Queue layout loaded. Please re-add music files.", "info");
						} catch (e) {
							console.error("Failed to parse saved queue metadata:", e);
							this._showToast("Failed to load queue layout (invalid data).", "error");
						}
					}
				} else {
					this._showToast("No saved queue layout found.", "info");
				}
			}
			// --- Drag and Drop ---
			_handleDragStart(e) {
				if(e.target.classList.contains('trackwid')) {
					this.draggedItem = e.target;
					e.dataTransfer.effectAllowed = 'move';
					e.dataTransfer.setData('text/plain', e.target.dataset.index); // Pass index
					// Slight delay to allow browser to capture drag image
					setTimeout(() => {
						e.target.classList.add('dragging');
					}, 0);
				}
			}
			_handleDragOver(e) {
				e.preventDefault(); // Necessary to allow drop
				e.dataTransfer.dropEffect = 'move';
				const targetItem = e.target.closest('.trackwid');
				if(targetItem && targetItem !== this.draggedItem) {
					this.dragOverItem = targetItem;
					const rect = targetItem.getBoundingClientRect();
					const offsetY = e.clientY - rect.top;
					const isBefore = offsetY < rect.height / 2;
					// Remove indicator from previous position
					this.dropIndicator.remove();
					if(isBefore) {
						// Insert indicator *before* the target item
						targetItem.parentNode.insertBefore(this.dropIndicator, targetItem);
					} else {
						// Insert indicator *after* the target item
						targetItem.parentNode.insertBefore(this.dropIndicator, targetItem.nextSibling);
					}
					this.dropIndicator.classList.remove('hidden');
				} else if(!targetItem) {
					// Dragging over empty space or container edge
					// Check if dragging over the main container and it's empty or near bottom
					if(e.target === this.dom.tracklistContainer && this.dom.tracklistContainer.children.length > 1) { // >1 to account for indicator potential
						// Append indicator at the end
						this.dropIndicator.remove();
						this.dom.tracklistContainer.appendChild(this.dropIndicator);
						this.dropIndicator.classList.remove('hidden');
					}
					this.dragOverItem = null; // Clear dragOverItem if not over a track
				}
			}
			_handleDragLeave(e) {
				// Hide indicator if leaving the container or not over a valid drop target within it
				if(e.target === this.dom.tracklistContainer || e.target.closest('.trackwid') === this.dragOverItem) {
					// Check if the *relatedTarget* (where the mouse is going) is outside the list
					if(!this.dom.tracklistContainer.contains(e.relatedTarget)) {
						this.dropIndicator.classList.add('hidden');
						this.dragOverItem = null;
					}
				}
			}
			_handleDrop(e) {
				e.preventDefault();
				this.dropIndicator.classList.add('hidden'); // Hide indicator on drop
				if(!this.draggedItem) return;
				const draggedIndex = parseInt(this.draggedItem.dataset.index, 10);
				let targetIndex = -1;
				// Find where the indicator was placed
				const children = Array.from(this.dom.tracklistContainer.children);
				const indicatorIndex = children.indexOf(this.dropIndicator);
				if(indicatorIndex !== -1) {
					// Get the index of the element *before* the indicator
					if(indicatorIndex > 0) {
						const itemBeforeIndicator = children[indicatorIndex - 1];
						if(itemBeforeIndicator && itemBeforeIndicator !== this.draggedItem) {
							targetIndex = parseInt(itemBeforeIndicator.dataset.index, 10) + 1;
						} else if(itemBeforeIndicator === this.draggedItem && children.length > 1) {
							// Dragged item was moved to be just before itself (edge case?)
							// Let's assume it means dropping at the same logical position or slightly after
							// Trying index of item *after* indicator if exists
							if(indicatorIndex < children.length - 1) {
								const itemAfterIndicator = children[indicatorIndex + 1];
								if(itemAfterIndicator) {
									targetIndex = parseInt(itemAfterIndicator.dataset.index, 10);
								} else {
									targetIndex = this.trackList.length;
								} // Append if no item after
							} else {
								targetIndex = this.trackList.length; // Append if last item dragged below itself
							}
						} else {
							targetIndex = 0; // Dropped at the very beginning
						}
					} else {
						targetIndex = 0; // Dropped at the very beginning (indicator was first)
					}
				} else {
					// Fallback: if indicator somehow wasn't placed, maybe append?
					targetIndex = this.trackList.length;
				}
				// Adjust target index if moving item downwards
				if(draggedIndex < targetIndex) {
					targetIndex--;
				}
				// Check if drop is effectively a no-op
				if(targetIndex === draggedIndex) {
					console.log("Drop resulted in no change.");
					this.draggedItem.classList.remove('dragging');
					this.draggedItem = null;
					return;
				}
				// Move item in the array
				const [movedTrack] = this.trackList.splice(draggedIndex, 1);
				this.trackList.splice(targetIndex, 0, movedTrack);
				// Update currentIndex if affected
				if(this.currentIndex === draggedIndex) {
					this.currentIndex = targetIndex;
				} else if(draggedIndex < this.currentIndex && targetIndex >= this.currentIndex) {
					this.currentIndex--;
				} else if(draggedIndex > this.currentIndex && targetIndex <= this.currentIndex) {
					this.currentIndex++;
				}
				// If not shuffled, update originalOrderTrackList similarly
				if(!this.isShuffled) {
					const [movedOriginal] = this.originalOrderTrackList.splice(draggedIndex, 1);
					this.originalOrderTrackList.splice(targetIndex, 0, movedOriginal);
				}
				// Clean up and re-render
				this.draggedItem.classList.remove('dragging');
				this.draggedItem = null;
				this.dragOverItem = null;
				this.renderQueue(); // Re-render the list with new order
			}
			_handleDragEnd(e) {
				// Clean up in case drop didn't happen correctly
				if(this.draggedItem) {
					this.draggedItem.classList.remove('dragging');
				}
				this.dropIndicator.classList.add('hidden');
				this.draggedItem = null;
				this.dragOverItem = null;
			}
			// --- Playback Controls ---
			loadTrack(index) {
				if(index < 0 || index >= this.trackList.length) {
					console.error("Invalid track index:", index);
					if(this.trackList.length > 0) this.loadTrack(0); // Load first if possible
					else this._resetPlayerUI();
					return;
				}
				this._resumeAudioContext(); // Ensure context is running before loading
				clearInterval(this.updateTimer);
				this._resetSeekSlider(); // Reset visual progress
				this.currentIndex = index;
				const track = this.trackList[index];
				if(!track || !track.path) {
					console.error("Track data or path missing for index:", index, track);
					this._showToast("Error loading track data.", "error");
					this.nextTrack(); // Try next track
					return;
				}
				this.dom.trackName.textContent = track.name;
				this.dom.trackName.title = track.name; // Tooltip
				this.dom.trackArtist.textContent = track.artist;
				this.dom.trackArtist.title = track.artist;
				this.dom.nowPlaying.textContent = `Playing ${index + 1} of ${this.trackList.length}`;
				// Update album art and background
				this._updateAlbumArt(track.albumArt);
				this._updateBitrateStat(track.bitrate); // Update stats if available
				// Set audio source
				// Check if path is a Base64 Data URL
				if(track.path.startsWith('data:audio')) {
					this.audioElement.src = track.path;
				} else {
					// Handle other path types if necessary (e.g., file identifiers, URLs)
					console.warn("Track path is not a Data URL:", track.path);
					// Assuming it might be a blob URL or similar accessible directly
					this.audioElement.src = track.path;
				}
				this.audioElement.load(); // Important: Trigger loading metadata and audio data
				// Highlight in queue
				this.renderQueue(); // Re-render to update 'playing' class
				// Don't auto-play here; wait for 'loadedmetadata' or explicit play command
				// This prevents issues if the file is large or network is slow.
				this.pauseTrack(true); // Set UI to paused state initially
			}
			_onTrackLoaded() {
				// Called when enough metadata (like duration) is loaded
				if(isNaN(this.audioElement.duration)) return; // Sometimes fires too early
				const duration = this.audioElement.duration;
				this.dom.seekSlider.max = duration; // Set slider max to duration in seconds
				this.dom.totalDuration.textContent = this._formatTime(duration);
				this._updateSliderBg(this.dom.seekSlider); // Initial background for seek
				console.log(`Track loaded: ${this.trackList[this.currentIndex]?.name}, Duration: ${this._formatTime(duration)}`);
				// If it was intended to play immediately after load (e.g., after clicking track)
				if(this.isPlaying) {
					this.playTrack();
				}
			}
			_onTrackEnded() {
				console.log("Track ended:", this.trackList[this.currentIndex]?.name);
				if(this.loopMode === 'one') {
					this.seekToValue(0); // Seek to beginning
					this.playTrack();
				} else if(this.loopMode === 'all') {
					this.nextTrack(); // Will loop back to start if at end
				} else { // loopMode === 'none'
					// Play next only if not the last track
					if(this.currentIndex < this.trackList.length - 1) {
						this.nextTrack();
					} else {
						// Reached end of queue, stop playback
						this.pauseTrack();
						this.seekToValue(0); // Reset slider to beginning
						// Maybe visually indicate end of queue reached?
					}
				}
			}
			_handleAudioError(e) {
				console.error("Audio Element Error:", e);
				let errorMessage = "An error occurred playing this track.";
				const trackName = this.trackList[this.currentIndex]?.name || 'the track';
				switch(this.audioElement.error?.code) {
				case MediaError.MEDIA_ERR_ABORTED:
					errorMessage = `Loading aborted for ${trackName}.`;
					break;
				case MediaError.MEDIA_ERR_NETWORK:
					errorMessage = `Network error loading ${trackName}.`;
					break;
				case MediaError.MEDIA_ERR_DECODE:
					errorMessage = `Cannot decode ${trackName}. File might be corrupt or unsupported.`;
					break;
				case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
					errorMessage = `Format not supported for ${trackName}.`;
					break;
				default:
					errorMessage = `Unknown error playing ${trackName}.`;
				}
				this._showToast(errorMessage, "error");
				// Optionally try to play the next track automatically
				this.nextTrack();
			}
			playpauseTrack() {
				if(this.currentIndex === -1 && this.trackList.length > 0) {
					// No track selected, but queue has items - load the first one
					this.loadTrack(0);
					// loadTrack now calls pauseTrack(true), so we need to immediately request play
					this.isPlaying = true; // Set intention to play
					// Play will start once metadata is loaded (_onTrackLoaded checks isPlaying)
				} else if(this.currentIndex !== -1) {
					// Track is loaded or loading
					if(this.isPlaying) {
						this.pauseTrack();
					} else {
						this.playTrack();
					}
				} else {
					this._showToast("Queue is empty. Add songs first.", "info");
				}
			}
			playTrack() {
				if(this.currentIndex === -1 || !this.audioElement.src) return; // No track to play
				this._resumeAudioContext(); // Ensure context is active
				// Check readyState - 4 means enough data is available to play
				if(this.audioElement.readyState >= 2) { // HAVE_CURRENT_DATA or more
					this.audioElement.play().then(() => {
						this.isPlaying = true;
						this.dom.playpauseBtn.innerHTML = `<span class="material-symbols-rounded">pause_circle</span>`;
						this.dom.playpauseBtn.title = "Pause";
						clearInterval(this.updateTimer); // Clear any existing timer
						this.updateTimer = setInterval(() => this.seekUpdate(), 500); // Update timer more frequently
						this.seekUpdate(); // Initial update
						this._startVisualizer(); // Start animation loop
						console.log("Playback started.");
					}).catch(error => {
						console.error('Error starting playback:', error);
						this._showToast(`Playback error: ${error.message}`, "error");
						this.isPlaying = false; // Ensure state consistency
						this.dom.playpauseBtn.innerHTML = `<span class="material-symbols-rounded">play_circle</span>`;
						this.dom.playpauseBtn.title = "Play";
					});
				} else {
					// Not ready yet, set the flag and wait for 'canplay' or 'loadedmetadata'
					this.isPlaying = true; // Set the *intent* to play
					this.dom.playpauseBtn.innerHTML = `<span class="material-symbols-rounded">hourglass_top</span>`; // Indicate loading/waiting
					this.dom.playpauseBtn.title = "Loading...";
					console.log("Waiting for audio data to start playback...");
					// Add a one-time listener for canplay
					this.audioElement.oncanplay = () => {
						if(this.isPlaying) { // Check if still intended to play
							this.playTrack(); // Try again now that it's ready
						}
						this.audioElement.oncanplay = null; // Remove listener
					};
				}
			}
			pauseTrack(uiOnly = false) { // uiOnly flag prevents actual pause if needed
				if(!uiOnly) {
					this.audioElement.pause();
					this.isPlaying = false;
					console.log("Playback paused.");
				} else {
					// This case is used when loading a track - we want the UI to show paused
					// but don't necessarily set this.isPlaying to false if auto-play is intended.
					console.log("Setting UI to paused state.");
				}
				this.dom.playpauseBtn.innerHTML = `<span class="material-symbols-rounded">play_circle</span>`;
				this.dom.playpauseBtn.title = "Play";
				clearInterval(this.updateTimer);
				this._stopVisualizer();
			}
			nextTrack() {
				let nextIndex;
				if(this.isShuffled && this.trackList.length > 1) {
					// Simple shuffle: pick a random index different from the current one
					do {
						nextIndex = Math.floor(Math.random() * this.trackList.length);
					} while(nextIndex === this.currentIndex);
				} else {
					nextIndex = this.currentIndex + 1;
					// Handle looping for 'all' mode or end of list
					if(nextIndex >= this.trackList.length) {
						if(this.loopMode === 'all') {
							nextIndex = 0; // Wrap around
						} else {
							// End of queue in 'none' or 'one' loop mode
							this.pauseTrack();
							this.seekToValue(0);
							this._showToast("Reached end of queue.", "info");
							return; // Stop here
						}
					}
				}
				if(this.trackList.length > 0) {
					this.loadTrack(nextIndex);
					// loadTrack now sets isPlaying based on previous state, but needs correction here.
					// If next was called, we definitely want to play the next track.
					this.isPlaying = true; // Ensure playback continues
				} else {
					this._resetPlayerUI();
				}
			}
			prevTrack() {
				let prevIndex;
				if(this.isShuffled && this.trackList.length > 1) {
					// Simple shuffle: pick a random index different from the current one
					do {
						prevIndex = Math.floor(Math.random() * this.trackList.length);
					} while(prevIndex === this.currentIndex);
				} else {
					prevIndex = this.currentIndex - 1;
					if(prevIndex < 0) {
						if(this.loopMode === 'all') {
							prevIndex = this.trackList.length - 1; // Wrap around to end
						} else {
							// Beginning of queue in 'none' or 'one' loop mode
							this.seekToValue(0); // Go to start of current track instead of stopping
							return;
						}
					}
				}
				if(this.trackList.length > 0) {
					this.loadTrack(prevIndex);
					this.isPlaying = true; // Ensure playback continues
				} else {
					this._resetPlayerUI();
				}
			}
			seeking() {
				this.isSeeking = true; // Indicate manual seeking is in progress
				this.dom.currTime.textContent = this._formatTime(this.dom.seekSlider.value);
				this._updateSliderBg(this.dom.seekSlider);
			}
			seekTo() {
				if(!isNaN(this.audioElement.duration)) {
					this.audioElement.currentTime = this.dom.seekSlider.value;
					console.log("Seeked to:", this._formatTime(this.audioElement.currentTime));
				}
				this.isSeeking = false; // Seeking finished
				// No need to call seekUpdate manually, the interval timer will catch up
			}
			seekToValue(timeInSeconds) {
				if(!isNaN(this.audioElement.duration)) {
					const validTime = Math.max(0, Math.min(timeInSeconds, this.audioElement.duration));
					this.audioElement.currentTime = validTime;
					this.dom.seekSlider.value = validTime;
					this.seekUpdate(); // Update UI immediately
				}
			}
			seekUpdate() {
				if(this.isSeeking || !this.isPlaying || isNaN(this.audioElement.duration) || this.audioElement.currentTime === undefined) {
					return; // Don't update if manually seeking, paused, duration unknown, or time unknown
				}
				const currentTime = this.audioElement.currentTime;
				this.dom.seekSlider.value = currentTime;
				this.dom.currTime.textContent = this._formatTime(currentTime);
				this._updateSliderBg(this.dom.seekSlider);
			}
			_resetSeekSlider() {
				this.dom.seekSlider.value = 0;
				this.dom.seekSlider.max = 100; // Default max until duration known
				this.dom.currTime.textContent = "00:00";
				this.dom.totalDuration.textContent = "00:00";
				this._updateSliderBg(this.dom.seekSlider); // Reset background
			}
			toggleLoop() {
				if(this.loopMode === 'none') {
					this.loopMode = 'all';
				} else if(this.loopMode === 'all') {
					this.loopMode = 'one';
				} else { // loopMode === 'one'
					this.loopMode = 'none';
				}
				this._updateLoopButton();
				localStorage.setItem('musicPlayerLoopMode', this.loopMode);
				this._showToast(`Loop mode: ${this.loopMode}`, "info");
			}
			_updateLoopButton() {
				let icon = 'repeat';
				let title = 'Loop Mode: Off';
				this.dom.loopBtn.classList.remove('active');
				if(this.loopMode === 'all') {
					icon = 'repeat'; // Keep repeat icon
					title = 'Loop Mode: Queue';
					this.dom.loopBtn.classList.add('active');
				} else if(this.loopMode === 'one') {
					icon = 'repeat_one';
					title = 'Loop Mode: Track';
					this.dom.loopBtn.classList.add('active');
				}
				this.dom.loopBtn.innerHTML = `<span class="material-symbols-rounded">${icon}</span>`;
				this.dom.loopBtn.title = title;
			}
			toggleShuffle() {
				this.isShuffled = !this.isShuffled;
				this.dom.shuffleBtn.classList.toggle('active', this.isShuffled);
				if(this.isShuffled) {
					// Shuffle the current track list, but keep original order safe
					// Fisher-Yates Shuffle
					const array = this.trackList;
					for(let i = array.length - 1; i > 0; i--) {
						const j = Math.floor(Math.random() * (i + 1));
						if(i !== this.currentIndex && j !== this.currentIndex) { // Avoid swapping the current track if possible initially
							[array[i], array[j]] = [array[j], array[i]];
						} else if(i === this.currentIndex) {
							// If current track is 'i', swap 'j' with something else if 'j' is not end
							const k = (j === array.length - 1) ? j - 1 : array.length - 1; // pick last or second last valid index
							if(k !== i && k >= 0)[array[j], array[k]] = [array[k], array[j]];
							// Then swap i and j (original target)
							[array[i], array[j]] = [array[j], array[i]];
						} else { // j === this.currentIndex
							// If current track is 'j', swap 'i' with something else if 'i' is not end
							const k = (i === array.length - 1) ? i - 1 : array.length - 1; // pick last or second last valid index
							if(k !== j && k >= 0)[array[i], array[k]] = [array[k], array[i]];
							// Then swap i and j (original target)
							[array[i], array[j]] = [array[j], array[i]];
						}
					}
					// Find the new index of the currently playing track
					const currentTrackId = this.originalOrderTrackList[this.currentIndex]?.id; // Get ID from original if available
					if(currentTrackId) {
						this.currentIndex = this.trackList.findIndex(t => t.id === currentTrackId);
						if(this.currentIndex === -1 && this.trackList.length > 0) this.currentIndex = 0; // Fallback if ID not found
					} else if(this.trackList.length > 0) {
						this.currentIndex = 0; // Fallback
					} else {
						this.currentIndex = -1;
					}
					this._showToast("Shuffle enabled.", "info");
				} else {
					// Restore original order
					// Find current track ID before restoring
					const currentTrackId = (this.currentIndex > -1) ? this.trackList[this.currentIndex]?.id : null;
					this.trackList = [...this.originalOrderTrackList];
					// Find the new index of the current track in the restored list
					if(currentTrackId) {
						this.currentIndex = this.trackList.findIndex(t => t.id === currentTrackId);
						if(this.currentIndex === -1 && this.trackList.length > 0) this.currentIndex = 0; // Fallback
					} else if(this.trackList.length > 0) {
						this.currentIndex = 0; // Fallback
					} else {
						this.currentIndex = -1;
					}
					this._showToast("Shuffle disabled.", "info");
				}
				localStorage.setItem('musicPlayerIsShuffled', this.isShuffled);
				this.renderQueue(); // Re-render with new order or shuffle state
			}
			// --- UI Updates & Helpers ---
			_updateAlbumArt(artUrl) {
				if(artUrl) {
					this.dom.baseImg.src = artUrl;
					// Get dominant color async for shadow
					this._getDominantColorAsync(artUrl).then(color => {
						this.dom.baseImg.style.boxShadow = `0 5px 20px ${color}80`; // Add some transparency
						// Maybe update theme based on album art? Optional.
						// this.setAccentColor(color);
					});
				} else {
					this.dom.baseImg.src = ''; // Clear image
					this.dom.baseImg.style.boxShadow = 'none'; // Remove shadow
				}
			}
			_resetPlayerUI() {
				this.dom.trackName.textContent = 'No Track Loaded';
				this.dom.trackArtist.textContent = 'Unknown Artist';
				this.dom.nowPlaying.textContent = '---';
				this.dom.baseImg.src = '';
				this.dom.baseImg.style.boxShadow = 'none';
				this._resetSeekSlider();
			}
			_formatTime(seconds) {
				if(isNaN(seconds) || seconds === Infinity) {
					return "--:--";
				}
				const mins = Math.floor(seconds / 60);
				const secs = Math.floor(seconds % 60);
				return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
			}
			_updateSliderBg(slider) {
				const min = slider.min || 0;
				const max = slider.max || 100;
				const value = slider.value || 0;
				const percentage = ((value - min) / (max - min)) * 100;
				// Use the accent color for the fill part
				slider.style.background = `linear-gradient(to right, var(--main-color) ${percentage}%, var(--slider-track) ${percentage}%)`;
			}
			_showToast(message, type = "info") { // type: info, success, warning, error
				console.log(`[${type.toUpperCase()}] ${message}`);
				// Optional: Implement a more user-friendly toast notification system
				if(window.parent && typeof window.parent.say === 'function') {
					const statusMap = {
						'info': 'info',
						'success': 'success',
						'warning': 'warn',
						'error': 'failed'
					};
					window.parent.say(message, statusMap[type] || 'info');
				} else {
					// Fallback alert for standalone
					// alert(`[${type.toUpperCase()}] ${message}`);
				}
			}
			_handleKeyDown(e) {
				// Ignore if typing in search input or settings inputs
				if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
					return;
				}
				switch(e.code) {
				case 'Space':
					e.preventDefault();
					this.playpauseTrack();
					break;
				case 'ArrowRight':
					e.preventDefault();
					try {
						this.nextTrack();
					} catch (err) {} // Catch errors during quick multi-presses
					break;
				case 'ArrowLeft':
					e.preventDefault();
					try {
						this.prevTrack();
					} catch (err) {}
					break;
				case 'ArrowUp':
					e.preventDefault();
					let volUp = Math.min(100, parseInt(this.dom.volumeSlider.value) + 5);
					this.dom.volumeSlider.value = volUp;
					this.setVolume();
					break;
				case 'ArrowDown':
					e.preventDefault();
					let volDown = Math.max(0, parseInt(this.dom.volumeSlider.value) - 5);
					this.dom.volumeSlider.value = volDown;
					this.setVolume();
					break;
					// Add more shortcuts: 'M' for mute, 'L' for loop, 'S' for shuffle?
				}
			}
			// --- Visualizer ---
			_resizeCanvas() {
				// Make main visualizer canvas cover the entire body background
				this.dom.visualizerCanvas.width = window.innerWidth;
				this.dom.visualizerCanvas.height = window.innerHeight;
				// Resize nerd stats canvas
				this.dom.freqCanvas.width = this.dom.freqCanvas.clientWidth; // Use clientWidth for CSS size
				this.dom.freqCanvas.height = this.dom.freqCanvas.clientHeight;
				// If resizing clears content, restart visualizer if playing
				if(this.isPlaying && this.visualizerType !== 'off') {
					this._startVisualizer();
				} else {
					this._drawVisualizerFrame(); // Draw initial static frame if needed
				}
			}
			setVisualizerType(type) {
				this.visualizerType = type;
				if(this.isPlaying) {
					this._stopVisualizer(); // Stop current loop
					if(type !== 'off') {
						this._startVisualizer(); // Start new loop if not 'off'
					} else {
						// Clear canvases if turned off while playing
						this.visualizerCtx.clearRect(0, 0, this.dom.visualizerCanvas.width, this.dom.visualizerCanvas.height);
						this.freqCtx.clearRect(0, 0, this.dom.freqCanvas.width, this.dom.freqCanvas.height);
					}
				} else {
					// Just draw static frame if paused
					this._drawVisualizerFrame();
				}
			}
			_startVisualizer() {
				if(this.animationFrameId || !this.analyserNode || this.visualizerType === 'off') return; // Already running or nothing to visualize or turned off
				const loop = () => {
					this._drawVisualizerFrame();
					this.animationFrameId = requestAnimationFrame(loop);
				};
				this.animationFrameId = requestAnimationFrame(loop);
			}
			_stopVisualizer() {
				if(this.animationFrameId) {
					cancelAnimationFrame(this.animationFrameId);
					this.animationFrameId = null;
				}
			}
			_redrawVisualizer() {
				// Called when theme changes etc. - redraw static frame
				if(!this.isPlaying) {
					this._drawVisualizerFrame();
				}
			}
			_drawVisualizerFrame() {
				if(!this.analyserNode) {
					// Draw default backgrounds if analyser not ready
					this.visualizerCtx.fillStyle = getComputedStyle(document.body).backgroundColor || '#101010';
					this.visualizerCtx.fillRect(0, 0, this.dom.visualizerCanvas.width, this.dom.visualizerCanvas.height);
					this.freqCtx.fillStyle = getComputedStyle(this.dom.freqCanvas).backgroundColor || '#272727';
					this.freqCtx.fillRect(0, 0, this.dom.freqCanvas.width, this.dom.freqCanvas.height);
					return;
				}
				// Get data ONLY if playing (or needed for static view)
				if(this.isPlaying || !this.animationFrameId) { // Get data if playing OR if drawing static frame
					this.analyserNode.getByteFrequencyData(this.analyserDataArray);
				} else if(!this.isPlaying && this.animationFrameId) {
					// Paused, but animation loop is running (e.g., was just paused) - stop getting new data
					// Keep drawing last frame or clear? Let's clear/fade out
				}
				// --- 1. Main Background Visualizer (Particles) ---
				const mainCanvas = this.dom.visualizerCanvas;
				const mainCtx = this.visualizerCtx;
				mainCtx.fillStyle = 'rgba(16, 16, 16, 0.1)'; // Fading effect
				mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
				if(this.visualizerType === 'particles') {
					const volume = this.analyserDataArray.reduce((sum, value) => sum + value, 0) / this.analyserBufferLength;
					const bass = (this.analyserDataArray[2] || 0) / 255; // Sample low frequency
					const treble = (this.analyserDataArray[this.analyserBufferLength - 10] || 0) / 255; // Sample high freq
					// Add/remove particles based on volume/activity
					const targetParticles = this.baseNumParticles + Math.floor(volume * 1.5);
					while(this.particlesArray.length < targetParticles) {
						this.particlesArray.push(new Particle(mainCanvas.width, mainCanvas.height));
					}
					while(this.particlesArray.length > targetParticles && this.particlesArray.length > this.baseNumParticles) {
						this.particlesArray.shift(); // Remove oldest particles
					}
					// Update and draw particles
					mainCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-color') || '#00ff50';
					this.particlesArray.forEach(particle => {
						particle.update(bass, treble, volume);
						particle.draw(mainCtx);
					});
				}
				// --- 2. Nerd Stats Frequency Bars Visualizer ---
				const freqCanvas = this.dom.freqCanvas;
				const freqCtx = this.freqCtx;
				freqCtx.fillStyle = getComputedStyle(freqCanvas).backgroundColor || '#272727'; // Background for freq bars
				freqCtx.fillRect(0, 0, freqCanvas.width, freqCanvas.height);
				if(this.visualizerType === 'bars') {
					const barWidth = (freqCanvas.width / this.analyserBufferLength) * 1.5; // Slightly wider bars
					let x = 0;
					const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--main-color') || '#00ff50';
					for(let i = 0; i < this.analyserBufferLength; i++) {
						const barHeight = (this.analyserDataArray[i] / 255) * freqCanvas.height * 0.9; // Scale height
						// Gradient or solid color for bars
						// const gradient = freqCtx.createLinearGradient(x, freqCanvas.height, x, freqCanvas.height - barHeight);
						// gradient.addColorStop(0, accentColor + '80'); // More transparent at bottom
						// gradient.addColorStop(1, accentColor); // Solid at top
						// freqCtx.fillStyle = gradient;
						freqCtx.fillStyle = accentColor;
						freqCtx.fillRect(x, freqCanvas.height - barHeight, barWidth, barHeight);
						x += barWidth + 1; // Add spacing between bars
					}
				} else if(this.visualizerType === 'particles') {
					// Maybe draw something simple on freq canvas when particles are active? Or leave blank.
					// freqCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
					// freqCtx.textAlign = 'center';
					// freqCtx.fillText("Particles Active", freqCanvas.width / 2, freqCanvas.height / 2);
				}
			}
		} // End of MusicPlayer Class
		// --- Particle Class (for visualizer) ---
		class Particle {
			constructor(canvasWidth, canvasHeight) {
				this.canvasWidth = canvasWidth;
				this.canvasHeight = canvasHeight;
				this.reset();
			}
			reset() {
				this.x = Math.random() * this.canvasWidth;
				this.y = Math.random() * this.canvasHeight;
				this.baseSize = Math.random() * 1.5 + 0.5; // Smaller base size
				this.size = this.baseSize;
				this.speedX = (Math.random() - 0.5) * 1; // Slower base speed
				this.speedY = (Math.random() - 0.5) * 1;
				this.opacity = Math.random() * 0.5 + 0.1; // Start with some opacity
			}
			update(bass, treble, volume) {
				// Move based on overall volume and specific frequencies
				const speedMultiplier = 1 + (volume / 255) * 2; // More responsive speed
				this.x += this.speedX * speedMultiplier + (bass - 0.5) * 0.5; // Nudge based on bass
				this.y += this.speedY * speedMultiplier + (treble - 0.5) * 0.5; // Nudge based on treble
				// Wrap around edges
				if(this.x > this.canvasWidth + this.size) this.x = -this.size;
				if(this.x < -this.size) this.x = this.canvasWidth + this.size;
				if(this.y > this.canvasHeight + this.size) this.y = -this.size;
				if(this.y < -this.size) this.y = this.canvasHeight + this.size;
				// Size pulsation based on bass
				this.size = this.baseSize + bass * 5;
				// Fade slightly over time or when inactive? (Optional)
				// this.opacity -= 0.001;
				// if (this.opacity <= 0) this.reset();
			}
			draw(ctx) {
				// Use the global accent color
				ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-color') + Math.round(this.opacity * 255).toString(16).padStart(2, '0'); // Apply opacity
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
			}
		}
		// --- Global Initialization ---
		let musicPlayer;
		document.addEventListener('DOMContentLoaded', () => {
			musicPlayer = new MusicPlayer();
			// Expose to global scope for button clicks if needed, though class methods handle most.
			window.musicPlayer = musicPlayer;
		});
	</script>
</body>

</html>